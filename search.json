[{"title":"PHP链接数据库的几种方法","path":"/2024/08/11/7/","content":"前言在PHP中执行SQL查询后，有人就不会读取数据库里面的内容，这里就写上三种读取数据库的方法 fetch_assoc方法使用 fetch_assoc 方法获取关联数组。对于 SELECT 查询，可以使用 fetch_assoc 方法从结果集中获取下一行作为关联数组。每次调用 fetch_assoc 将返回结果集的下一行，直到没有更多行为止。 123456789// fetch_assoc方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_assoc();while ($row !== null) &#123; // ... $row = $result-&gt;fetch_assoc();&#125; fetch_row方法使用 fetch_row 方法获取索引数组。类似地，你也可以使用 fetch_row 方法从结果集中获取下一行作为索引数组。 123456789// fetch_row方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_row();while ($row !== null) &#123; // ... $row = $result-&gt;fetch_row();&#125; fetch_array方法使用 fetch_array 方法获取关联数组或索引数组。fetch_array 方法可以返回关联数组、索引数组或两者兼具的混合数组。你可以传递 MYSQLI_ASSOC、MYSQLI_NUM 或 MYSQLI_BOTH 作为参数来指定返回类型。 12345678910// fetch_array方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_array(MYSQLI_ASSOC);while ($row !== null) &#123; // ... $row = $result-&gt;fetch_array(MYSQLI_ASSOC);&#125;"},{"title":"使用VPS架设Minecraft服务器","path":"/2024/08/11/1/","content":"前言Minecraft是是一个开放世界沙盒游戏，但是大多数时间都是我们一个人在玩，非常孤独，玩别人的服务器但是限制多多，很多人就想自己当腐竹，但是又不知道怎么开服务器，那么我今天就来说说怎么架设一个基岩版&#x2F;Java版服务器。 准备工具 一台性能足够的Ubuntu系统服务器，2h4g起步 一个SSH连接工具，电脑手机均可 脑子 安装MCSM面板MCSManager 是一款开源，分布式，一键部署，支持 Minecraft 和 Steam 游戏服务器 的控制面板。MCSManager 在 Minecraft 和 其他游戏 社区内中已有一定的流行程度，它可以帮助你集中管理多个物理服务器，动态在任何主机上创建游戏服务端，并且提供安全可靠的多用户权限系统，可以很轻松的帮助你管理多个服务器。 准备环境默认情况下，一键安装脚本应该已经包含一切所需环境。如果是手动安装的情况下，你需满足 Node 16+ 运行时环境。Node 环境下载前往：https://nodejs.org/zh-cn/ 下载一键安装脚本1sudo su -c &quot;wget -qO- https://mcsmanager.com/install-v10.sh | bash&quot; 启动面板1234567891011121314# 先启动面板守护进程。# 这是用于进程控制，终端管理的服务进程。systemctl start mcsm-daemon.service# 再启动面板 Web 服务。# 这是用来实现支持网页访问和用户管理的服务。systemctl start mcsm-web.service# 重启面板命令systemctl restart mcsm-daemon.servicesystemctl restart mcsm-web.service# 停止面板命令systemctl stop mcsm-web.servicesystemctl stop mcsm-daemon.service 架设基岩版服务器前往官网下载服务端： https://www.minecraft.net/zh-hans/download/server/bedrock 下滑，找到Ubuntu版的服务端，点击下载： 下载速度慢可以挂梯子 接下来按照图片一步一步来点击侧边栏 我在这里翻过车，一定要记住，基岩版的启动命令是： 1./bedrock_server Java也大差不差，下载服务端然后启动服务器即可。"},{"title":"简述pjax及其实现原理","path":"/2024/08/11/6/","content":"简述pjax及实现方法什么是pjaxpjax是一种无刷新页面加载技术，它利用了浏览器的History API、XMLHttpRequest和HTML5的pushState方法，使得页面无需重新加载就可以实现局部更新。pjax可以让页面的转换更加流畅，并且可以减少服务器负载，提升用户体验。 实现方法1. 引入jquery.pjax.js插件 pjax最初由GitHub团队开发，后来被封装成了jquery.pjax.js插件。在使用pjax之前，需要先引入该插件。 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js&quot;&gt;&lt;/script&gt; 2. 修改a标签在使用pjax的页面中，所有的链接必须添加 data-pjax 属性，以告诉pjax这是一个需要无刷新加载的链接。 1&lt;a href=&quot;/example&quot; data-pjax&gt;Example&lt;/a&gt; 3. 监听pjax事件当用户点击pjax链接时，会触发 pjax:click 事件。我们可以在该事件中执行一些操作，例如显示loading动画等。 123$(document).on(&#x27;pjax:click&#x27;, function() &#123; // 显示loading动画&#125;); 当pjax请求完成并且页面更新成功时，会触发 pjax:success 事件。我们可以在该事件中执行一些操作，例如重置页面状态等。 123$(document).on(&#x27;pjax:success&#x27;, function() &#123; // 重置页面状态&#125;); 4. 配置pjax在使用pjax之前，可以通过 $.pjax.defaults 对象来配置pjax的一些参数，例如容器元素选择器、超时时间等。 12$.pjax.defaults.timeout = 5000;$.pjax.defaults.container = &#x27;#pjax-container&#x27;; pjax技术的实现并不复杂，只需要引入jquery.pjax.js插件，随便改改a标签，监听pjax的事件，配置参数即可。当然，在实际项目中，我们还需要考虑一些安全性、兼容性等问题。pjax可以使页面更加流畅，提升用户体验，但是也需要谨慎使用，避免出现不必要的问题，比如很多JavaScript函数不可用什么的"},{"title":"PHP做语法转换工具","path":"/2024/08/11/5/","content":"最近不是把博客的一些文章从和HTML转到Markdown了吗，因为之前换到了wordpress所以是HTML，但是这些文章再typecho无法被解析，于是就打算开发一个Markdown2HTML工具下面使我的开发笔记，可能比较含糊 项目结构一般情况下，我不会这么干，但是为了文章，还是需要定义的项目结构： 12345678markdown2html/│├── index.php├── convert.php├── styles/│ └── bootstrap.min.css└── js/ └── bootstrap.bundle.min.js index.php: 前端页面，包含输入框和按钮。 convert.php: 后端逻辑处理，将HTML转换为Markdown或将Markdown转换为HTML。 styles/: 存放CSS文件。 js/: 存放JavaScript文件。 准备工作下载Bootstrap从Bootstrap官方网站下载最新版本的Bootstrap，并将bootstrap.min.css放入styles/文件夹，将bootstrap.bundle.min.js放入js/文件夹。也就是所谓的按需导入 编写前端页面 (index.php)编写前端页面，包含一个文本输入框和两个按钮，分别用于将HTML转换为Markdown和将Markdown转换为HTML。这里不要求好看，而且需要快速开发响应式页面，所以选择bootstrap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;转换工具&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container mt-5&quot;&gt; &lt;h1 class=&quot;text-center&quot;&gt;转换工具&lt;/h1&gt; &lt;form id=&quot;convertForm&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;inputText&quot; class=&quot;form-label&quot;&gt;Input Text&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;inputText&quot; name=&quot;inputText&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;d-flex justify-content-between&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; onclick=&quot;convert(&#x27;html2markdown&#x27;)&quot;&gt;HTML转Markdown&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; onclick=&quot;convert(&#x27;markdown2html&#x27;)&quot;&gt;Markdown转HTML&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;label for=&quot;outputText&quot; class=&quot;form-label&quot;&gt;Output Text&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;outputText&quot; name=&quot;outputText&quot; rows=&quot;10&quot; readonly&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=&quot;js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function convert(action) &#123; const form = document.getElementById(&#x27;convertForm&#x27;); const formData = new FormData(form); formData.append(&#x27;action&#x27;, action); fetch(&#x27;convert.php&#x27;, &#123; method: &#x27;POST&#x27;, body: formData &#125;) .then(response =&gt; response.text()) .then(data =&gt; &#123; document.getElementById(&#x27;outputText&#x27;).value = data; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写后端逻辑 (convert.php)接下来，编写后端逻辑，将HTML转换为Markdown或将Markdown转换为HTML。 1234567891011121314151617181920&lt;?phprequire &#x27;vendor/autoload.php&#x27;; // 使用Composer加载依赖use League\\HTMLToMarkdown\\HtmlConverter;use Michelf\\Markdown;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123; $inputText = $_POST[&#x27;inputText&#x27;]; $action = $_POST[&#x27;action&#x27;]; if ($action === &#x27;html2markdown&#x27;) &#123; $converter = new HtmlConverter(); $outputText = $converter-&gt;convert($inputText); &#125; elseif ($action === &#x27;markdown2html&#x27;) &#123; $outputText = Markdown::defaultTransform($inputText); &#125; echo $outputText;&#125;?&gt; 添加依赖需要安装两个PHP库来实现转换功能： Composer是一个包管理器，类似node的npm，和我发现PHP和Vue有异曲同工之妙 league/html-to-markdown: 将HTML转换为Markdown。 michelf/php-markdown: 将Markdown转换为HTML。 在项目根目录下创建一个composer.json文件，内容如下： 123456&#123; &quot;require&quot;: &#123; &quot;league/html-to-markdown&quot;: &quot;^5.0&quot;, &quot;michelf/php-markdown&quot;: &quot;^1.9&quot; &#125;&#125; 然后运行composer install来安装这些依赖。 1composer install 最终效果启动本地服务器（例如使用php -S localhost:8000），访问http://localhost:8000/，就可以看到转换工具的界面了。"},{"title":"万般皆是命，半点不由人","path":"/2024/08/11/4/","content":"「缘起，是人生的起点；命运，是注定的轨迹。万般皆是命，半点不由人。我们如同棋子，被命运摆弄着在生命的棋局中行走，无法逃离他们所设定的轨迹。然而，就像棋盘上的棋子一样，我们仍然可以选择着自己的落脚点和前进方向。 命运是一幅纷繁复杂的画卷，细细观察，会发现其中蕴含着深刻的道理。曾有一位古代智者说过：“人生自古谁无死，留取丹心照汗青。”这是对人生不可逆转性的深刻揭示。人们常常追求命运的改变，却常常被现实所限制。遗憾的是，我们无法挽回逝去的时光，无法改变已经发生的事实。然而，我们可以从中汲取教训，铭记历史，不要忘记我们曾经的那份初心。 人生的道路充满了艰辛和挫折，就像棋棋高手的棋局一样复杂多变。大师们常说：“棋逢对手，胜负乃前定。”命运的规则在人生的棋盘上显现，我们总是遭遇到强大的对手，面临各种棋局的考验。但我们不应气馁，因为我们始终拥有一个重要的选择权，那就是如何应对困难和挑战。 命运并不全然是一场噩梦，它也为我们埋下了希望的种子。埃莉诺·罗斯福曾经说过：“没有什么可以阻止一个怀揣希望的人。”即使命运摆放了种种难题，我们仍然能够抱着希望勇往直前。正如象棋中兵的进卒，只要它能够坚持到对方阵营，就能够晋升成一位更为强大的棋子。逆境中培养了我们的坚韧和毅力，命运越困难，我们越能够在其中找到希望的曙光。 在人类历史的长河中，智者们留下了许多关于命运的思考。拉伯雷曾说：“人从无法逃离的命运中总是选择假象，真实的命运不是我们创造的，而是被迫接受的。”我们往往倾向于将命运归罪于外界因素，却忽略了内心力量的作用。我们不能将自己束缚在无法逾越的命运轨迹中，而应该在命运的压迫下鼓起勇气，寻找自己的出口。 每个人都是自己命运的雕刻师。命运并不是一成不变的，它可以通过我们的努力而改变。古希腊哲学家伊壁鸠鲁在《幸福的修炼》中说：“命运不好者，很大程度上是因为不懂得在自己能力范围内，尽可能地选择能够给自己更好命运的方式。”我们应该懂得去追求自己内心的渴望，尽可能地创造我们想要的命运。 人生如棋，命运如局。即便被命运束缚，也不要丧失内心的力量和希望。在欢笑与泪水之间，我们渐渐明白，人生的真谛不在于命运的安排，而在于我们对命运的接受和应对。就像棋盘上的棋子，我们可以在有限的空间内创造属于自己的精彩。于须眉之间，凭借着聪明才智，我们与命运对峙，终将收获属于自己的胜利。 命运棋局，我们或落败或成功，但无论如何，我们始终要以从容之心面对命运的安排，在关键时刻做出明智的选择。因为，人生的棋局变幻莫测，命运的走位无常，唯有把握自己的棋局，方能踏上胜利的彼岸。不论人生如何多舛，我们都要坚信：万般皆是命，半点不由人。」"},{"title":"Android系统下针对Vue@cli环境的部署","path":"/2024/08/11/3/","content":"前言之前不是发过很多Android系统下安装环境的文章么，但是我发现Nginx和PHP现在都有专门的软件了，比如Ksweb、hopweb编辑器等等等等，但是针对Vue编辑&#x2F;开发&#x2F;预览的环境&#x2F;APP却没有，这里我就来写一篇Android系统下针对Vue@Cli环境的部署仅整活！不要用于生产环境！ Vue@Cli是什么Vue想必大家都知道是什么，但是Vue@Cli是什么呢？这个我之前说过： Vue@Cli是Vue.js官方提供的脚手架工具，它能够帮助我们快速搭建Vue.js项目，并提供了丰富的功能和插件。 缘起看到尤雨溪七年前的微博： 嗬！在手机上也能跑nodejs，有点儿意思哈。 准备首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。 软件一：Termux(ZeroTermux) 软件二：Spck Editor 软件三：一个浏览器(Chromr)还有要带脑子 安装环境打开ZeroTermux更新包列表： 1apt update 安装node.js环境： 1apt install nodejs 输入npm -v查看是否已经安装： 安装Vue@Cli: 1npm i vue-cli -g 创建一个Vue@Cli工程项目： 1vue init webpack vue-name 工程项目创建完成之后会有这些文件： 接下来开始预览： 1npm run dev 浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。 接下来开始打包： 1npm install 但是我这里好像打包失败了，但是不影响 创建软链接[仅root]由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即data&#x2F;data&#x2F;com.termux&#x2F;files目录下。 但是Android提供了软链接。 在Android系统中，用户主文件空间通常位于&#x2F;storage&#x2F;emulated&#x2F;0，但这个名字太长且不易记忆。Android提供了一个软链接路径&#x2F;sdcard，我们可以使用这个路径来简化操作。 1ln -s /data/data/com.termux/files/home/你的项目名称 /sdcard/你的目录"},{"title":"Python编写的一个Feed Rss读取器","path":"/2024/08/11/2/","content":"123456789101112131415161718192021222324import feedparserdef read_rss_feed(url): feed = feedparser.parse(url) print(&quot;标题:&quot;, feed.feed.title) print(&quot;简介:&quot;, feed.feed.description) print(&quot;链接:&quot;, feed.feed.link) print(&quot; 条目:&quot;) for entry in feed.entries: print(&quot; 标题:&quot;, entry.title) print(&quot;链接:&quot;, entry.link) if &#x27;summary&#x27; in entry: print(&quot;总结:&quot;, entry.summary) elif &#x27;description&#x27; in entry: print(&quot;简介:&quot;, entry.description) print(&quot;=&quot;*50) if __name__ == &quot;__main__&quot;: rss_feed_url = &quot;你的Rss链接&quot; read_rss_feed(rss_feed_url) 先导入了feedparser库。然后定义了一个read_rss_feed的函数。该函数接受一个URL参数，并使用 feedparser.parse(url)来解析该 URL 对应的 RSS 订阅源。接着，打印了整个订阅源的标题、简介和链接，并遍历每个条目并打印其标题、链接以及摘要或描述（如果有的话）。 在程序的主程序入口处，指定了一个 RSS 订阅源的 URL，并调用read_rss_feed函数来解析并打印该订阅源的内容。"},{"title":"Hello World","path":"/2024/08/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于博主","path":"/about/index.html","content":"联系方式 谷歌邮箱：&#x4d;&#101;&#x6e;&#x67;&#x5a;&#x65;&#50;&#x4d;&#x43;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109; QQ邮箱：&#x32;&#x33;&#x31;&#x37;&#49;&#x31;&#51;&#x32;&#x37;&#x38;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109; 企业邮箱：&#105;&#64;&#x6d;&#x65;&#x6e;&#x67;&#x7a;&#x65;&#x32;&#46;&#x63;&#x6e; Outlook邮箱：&#108;&#121;&#x6c;&#x35;&#49;&#56;&#64;&#111;&#x75;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d; QQ：2317113278 Xbox：MengZe2 微信：MengZe2_Minecraft Telegram：t.me&#x2F;MengZe_lin Github统计 本站群聊QQ群聊 Telegram频道https://t.me/mengze2cn Telegram群组https://t.me/+\\_hpAIMJKfBJhZDdl"},{"title":"友情链接","path":"/links/index.html","content":"程序更换，友链丢失 想和我做邻居吗？ 贵站长可在添加小站的友链后在留言板按如下格式留言，我看到留言且确认贵站已添加小站后会第一时间添加并发邮件通知贵站长 友链格式 12345贵站名称：名称贵站简介：简介贵站链接：链接贵站图片：图片站长邮箱：邮箱 ——————————————名称： 梦泽の日记网址： https://mengze2.cn图标： https://mengze2.cn/favicon.ico描述： 我也是普通人，我只不过在追求梦想罢了已添加贵站！—————————————— — 不收录有反动、色情、赌博等不良内容或提供不良内容链接的网站 本页面友链排序没有先后顺序，全都是随机排序 有些删除小站友链的站点小站也会在发现之后删除贵站，这点还望理解 https://xaoxuu.comhttps://xaoxuu.com"},{"title":"每日早报","path":"/newspaper/index.html","content":""},{"title":"免责声明","path":"/privacy-policy/index.html","content":"本博客旨在分享作者的个人技术经验和观点。所有内容仅供参考，不构成任何法律建议或专业意见。作者尽力确保信息准确性和可靠性，但不保证内容的完整性和时效性。 读者在使用本博客提供的信息或建议时，需自行承担风险。对于因使用本博客内容所引发的任何直接或间接损失，作者不承担任何责任。 本博客可能包含第三方链接或推荐的产品或服务，这些链接仅供方便参考，不构成认可或推荐。读者应自行评估并承担使用第三方链接或服务的风险。 作者保留随时更改或修订本免责声明的权利。建议读者定期查阅本页获取最新版本的免责声明。 如有任何疑问或建议，请联系作者。 最后更新日期：[2024-07-03]"}]