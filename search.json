[{"title":"最新消息，台风“贝碧嘉”预计将于9月15日夜间至16日上午在浙江台州至江苏启东一带沿海登陆，做好防台措施","path":"/post/19/","content":"今天下午，解放日报·上观新闻从中国气象局召开的通气会上获悉，台风“贝碧嘉”预计将于9月15日夜间至16日上午在浙江台州至江苏启东一带沿海登陆，登陆强度预计为台风级或强台风级，后强度逐渐减弱。截至今天上午11时，今年第13号台风“贝碧嘉”位干距离我国浙江省舟山市东偏南方约930公里的西北太平洋洋面上，强度为强热带风暴级，中心附近最大风力为28米每秒。目前，“贝碧嘉”预计以每小时30-35公里的速度向西北方向快速移动，强度逐渐增强，将于9月14日傍晚到夜间穿过琉球群岛，移入东海东部海面。中央气象台高级工程师刘达介绍，9月15日上午，台风“贝碧嘉”将逐渐转向西偏北方向移动，向我国华东沿海靠近。未来24小时，受台风”贝碧嘉”的影响，我国东海大部海域、华东沿海将有强烈的风雨。9月15日至17日，受台风“贝碧嘉”带来的强降雨影响，浙江、江苏、上海、安徽等地的沪昆、沈海、沪渝、京沪、沪陕、京台、沪蓉等高速公路道路积水风险高。中国气象局公共气象服务中心气象服务副首席冯蕾提醒，强降雨可能诱发路面塌方、道路水毁等次生灾害，易发生交通阻断。请公众及时关注天气预报信息，合理安排出行。如必需外出，注意避开高风险路段，行车时注意减速慢行，保持车距。铁路方面，9月15日至17日，浙江、上海、安徽等地境内的铁路线路，特别是宁波至绍兴段、上海至嘉兴段将受大暴雨影响。此外，15日至16日，无锡至苏州段、上海至嘉兴段高铁线路将受大风影响，可能发生列车晚点或者停运，公众需及时关注天气预报信息，合理安排出行。","tags":["台风"],"categories":["生活","新闻"]},{"title":"Awk文本/数据处理语言学习笔记","path":"/post/18/","content":"因为长期接触Termux这种Linux模拟环境，需要处理大量数据，在一位大佬那里了解到的Awk awk 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux&#x2F;unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。 awk命令格式和选项 语法形式 12awk [options] &#x27;script&#x27; var=value file(s)awk [options] -f scriptfile var=value file(s) 常用命令选项 **-F fs ** fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: **-v var&#x3D;value ** 赋值一个用户定义变量，将外部变量传递给awk **-f scripfile ** 从脚本文件中读取awk命令 **-m[fr] val ** 对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 awk模式和操作awk脚本是由模式和操作组成的。 模式模式可以是以下任意一个： &#x2F;正则表达式&#x2F;：使用通配符的扩展集。 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符~（匹配）和~!（不匹配）。 BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理 操作操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是： 变量或数组赋值 输出命令 内置函数 控制流语句 awk脚本基本结构1awk &#x27;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#x27; file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被 单引号 或 双引号 中，例如： 12awk &#x27;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#x27; filenameawk &quot;BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;&quot; filename awk的工作原理1awk &#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27; 第一步：执行BEGIN&#123; commands &#125;语句块中的语句； 第二步：从文件或标准输入(stdin)读取一行，然后执行pattern&#123; commands &#125;语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。 第三步：当读至输入流末尾时，执行END&#123; commands &#125;语句块。 BEGIN语句块 在awk开始从输入流中读取行 之前 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块 在awk从输入流中读取完所有的行 之后 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。 pattern语句块 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行&#123; print &#125;，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 示例 12345echo -e &quot;A line 1nA line 2&quot; | awk &#x27;BEGIN&#123; print &quot;Start&quot; &#125; &#123; print &#125; END&#123; print &quot;End&quot; &#125;&#x27;StartA line 1A line 2End 当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，例如： 12echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1,var2,var3; &#125;&#x27; v1 v2 v3 双引号拼接使用： 12echo | awk &#x27;&#123; var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; print var1&quot;=&quot;var2&quot;=&quot;var3; &#125;&#x27;v1=v2=v3 { }类似一个循环体，会对文件中的每一行进行迭代，通常变量初始化语句（如：i&#x3D;0）以及打印文件头部的语句放入BEGIN语句块中，将打印的结果等语句放在END语句块中。 awk内置变量（预定义变量）说明：[A][N][P][G]表示第一个支持变量的工具，[A]&#x3D;awk、[N]&#x3D;nawk、[P]&#x3D;POSIXawk、[G]&#x3D;gawk 12345678910111213141516171819202122 **$n** 当前记录的第n个字段，比如n为1表示第一个字段，n为2表示第二个字段。 **$0** 这个变量包含执行过程中当前行的文本内容。[N] **ARGC** 命令行参数的数目。[G] **ARGIND** 命令行中当前文件的位置（从0开始算）。[N] **ARGV** 包含命令行参数的数组。[G] **CONVFMT** 数字转换格式（默认值为%.6g）。[P] **ENVIRON** 环境变量关联数组。[N] **ERRNO** 最后一个系统错误的描述。[G] **FIELDWIDTHS** 字段宽度列表（用空格键分隔）。[A] **FILENAME** 当前输入文件的名。[P] **FNR** 同NR，但相对于当前文件。[A] **FS** 字段分隔符（默认是任何空格）。[G] **IGNORECASE** 如果为真，则进行忽略大小写的匹配。[A] **NF** 表示字段数，在执行过程中对应于当前的字段数。[A] **NR** 表示记录数，在执行过程中对应于当前的行号。[A] **OFMT** 数字的输出格式（默认值是%.6g）。[A] **OFS** 输出字段分隔符（默认值是一个空格）。[A] **ORS** 输出记录分隔符（默认值是一个换行符）。[A] **RS** 记录分隔符（默认是一个换行符）。[N] **RSTART** 由match函数所匹配的字符串的第一个位置。[N] **RLENGTH** 由match函数所匹配的字符串的长度。[N] **SUBSEP** 数组下标分隔符（默认值是34）。 示例 1234echo -e &quot;line1 f2 f3nline2 f4 f5nline3 f6 f7&quot; | awk &#x27;&#123;print &quot;Line No:&quot;NR&quot;, No of fields:&quot;NF, &quot;$0=&quot;$0, &quot;$1=&quot;$1, &quot;$2=&quot;$2, &quot;$3=&quot;$3&#125;&#x27; Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推： 123echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#x27;&#123;print $NF&#125;&#x27;f3f5 1234echo -e &quot;line1 f2 f3n line2 f4 f5&quot; | awk &#x27;&#123;print $(NF-1)&#125;&#x27;f2f4 打印每一行的第二和第三个字段： 1awk &#x27;&#123; print $2,$3 &#125;&#x27; filename 统计文件中的行数： 1awk &#x27;END&#123; print NR &#125;&#x27; filename 以上命令只使用了END语句块，在读入每一行的时，awk会将NR更新为对应的行号，当到达最后一行NR的值就是最后一行的行号，所以END语句块中的NR就是文件的行数。 一个每一行中第一个字段值累加的例子： 123456789seq 5 | awk &#x27;BEGIN&#123; sum=0; print &quot;总和：&quot; &#125; &#123; print $1&quot;+&quot;; sum+=$1 &#125; END&#123; print &quot;等于&quot;; print sum &#125;&#x27; 总和：1+2+3+4+5+等于15 将外部变量值传递给awk借助 -v选项 ，可以将外部值（并非来自stdin）传递给awk： 12VAR=10000echo | awk -v VARIABLE=$VAR &#x27;&#123; print VARIABLE &#125;&#x27; 另一种传递外部变量方法： 123var1=&quot;aaa&quot;var2=&quot;bbb&quot;echo | awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2 当输入来自于文件时使用： 1awk &#x27;&#123; print v1,v2 &#125;&#x27; v1=$var1 v2=$var2 filename 以上方法中，变量之间用空格分隔作为awk的命令行参数跟随在BEGIN、{}和END语句块之后。 awk运算与判断作为一种程序设计语言所应具有的特点之一，awk支持多种运算，这些运算与C语言提供的基本相同。awk还提供了一系列内置的运算函数（如log、sqr、cos、sin等）和一些用于对字符串进行操作（运算）的函数（如length、substr等等）。这些函数的引用大大的提高了awk的运算功能。作为对条件转移指令的一部分，关系判断是每种程序设计语言都具备的功能，awk也不例外，awk中允许进行多种测试，作为样式匹配，还提供了模式匹配表达式（匹配）和!（不匹配）。作为对测试的一种扩充，awk也支持用逻辑运算符。 算术运算符 运算符 描述 + - 加，减 * &#x2F; &amp; 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 例： 12awk &#x27;BEGIN&#123;a=&quot;b&quot;;print a++,++a;&#125;&#x27;0 2 注意：所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 赋值运算符 运算符 描述 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; **&#x3D; 赋值语句 例： 1a+=5; 等价于：a=a+5; 其它同类 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 例： 12awk &#x27;BEGIN&#123;a=1;b=2;print (a&gt;5 &amp;&amp; b&lt;=2),(a&gt;5 || b&lt;=2);&#125;&#x27;0 1 正则运算符 运算符 描述 ~ ~! 匹配正则表达式和不匹配正则表达式 例： 12awk &#x27;BEGIN&#123;a=&quot;100testa&quot;;if(a ~ /^100*/)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;ok 关系运算符 运算符 描述 &gt;&#x3D; !&#x3D; &#x3D;&#x3D; 关系运算符 例： 12awk &#x27;BEGIN&#123;a=11;if(a &gt;= 9)&#123;print &quot;ok&quot;;&#125;&#125;&#x27;ok 注意：&gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字才转为数值比较。字符串比较：按照ASCII码顺序比较。 其它运算符 运算符 描述 $ 字段引用 空格 字符串连接符 ?: C条件表达式 in 数组中是否存在某键值 例： 12awk &#x27;BEGIN&#123;a=&quot;b&quot;;print a==&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;;&#125;&#x27;ok 12awk &#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[1]=&quot;c&quot;;print (a in arr);&#125;&#x27;0 12awk &#x27;BEGIN&#123;a=&quot;b&quot;;arr[0]=&quot;b&quot;;arr[&quot;b&quot;]=&quot;c&quot;;print (a in arr);&#125;&#x27;1 运算级优先级表!级别越高越优先级别越高越优先 awk高级输入输出读取下一条记录awk中next语句使用：在循环逐行匹配，如果遇到next，就会跳过当前行，直接忽略下面语句。而进行下一行匹配。net语句一般用于多行合并： 12345678910cat text.txtabcdeawk &#x27;NR%2==1&#123;next&#125;&#123;print NR,$0;&#125;&#x27; text.txt2 b4 d 当记录行号除以2余1，就跳过当前行。下面的print NR,$0也不会执行。下一行开始，程序有开始判断NR%2值。这个时候记录行号是：2 ，就会执行下面语句块：&#39;print NR,$0&#39; 分析发现需要将包含有“web”行进行跳过，然后需要将内容与下面行合并为一行： 1234567891011121314151617181920cat text.txtweb01[192.168.2.100]httpd oktomcat oksendmail okweb02[192.168.2.101]httpd okpostfix okweb03[192.168.2.102]mysqld okhttpd ok0awk &#x27;/^web/&#123;T=$0;next;&#125;&#123;print T&quot;:t&quot;$0;&#125;&#x27; test.txtweb01[192.168.2.100]: httpd okweb01[192.168.2.100]: tomcat okweb01[192.168.2.100]: sendmail okweb02[192.168.2.101]: httpd okweb02[192.168.2.101]: postfix okweb03[192.168.2.102]: mysqld okweb03[192.168.2.102]: httpd ok 简单地读取一条记录awk getline用法：输出重定向需用到getline函数。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。 getline语法：getline var，变量var包含了特定行的内容。 awk getline从整体上来说，用法说明： 当其左右无重定向符|或&lt;时： getline作用于当前文件，读入当前文件的第一行给其后跟的变量var或$0（无变量），应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到的返回结果是隔行的。 当其左右有重定向符|或&lt;时： getline则作用于定向输入文件，由于该文件是刚打开，并没有被awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。 示例： 执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量out，并打印它： 1awk &#x27;BEGIN&#123; &quot;date&quot; | getline out; print out &#125;&#x27; test 执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给out，split函数把变量out转化成数组mon，然后打印数组mon的第二个元素： 1awk &#x27;BEGIN&#123; &quot;date&quot; | getline out; split(out,mon); print mon[2] &#125;&#x27; test 命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。 1awk &#x27;BEGIN&#123; while( &quot;ls&quot; | getline) print &#125;&#x27; 关闭文件awk中允许在程序中关闭一个输入或输出文件，方法是使用awk的close语句。 1close(&quot;filename&quot;) filename可以是getline打开的文件，也可以是stdin，包含文件名的变量或者getline使用的确切命令。或一个输出文件，可以是stdout，包含文件名的变量或使用管道的确切命令。 输出到一个文件awk中允许用如下方式将结果输出到一个文件： 123echo | awk &#x27;&#123;printf(&quot;hello word!n&quot;) &gt; &quot;datafile&quot;&#125;&#x27;或echo | awk &#x27;&#123;printf(&quot;hello word!n&quot;) &gt;&gt; &quot;datafile&quot;&#125;&#x27; 设置字段定界符默认的字段定界符是空格，可以使用-F &quot;定界符&quot; 明确指定一个定界符： 123awk -F: &#x27;&#123; print $NF &#125;&#x27; /etc/passwd或awk &#x27;BEGIN&#123; FS=&quot;:&quot; &#125; &#123; print $NF &#125;&#x27; /etc/passwd 在BEGIN语句块中则可以用OFS=“定界符”设置输出字段的定界符。 流程控制语句在linux awk的while、do-while和for语句中允许使用break,continue语句来控制流程走向，也允许使用exit这样的语句来退出。break中断当前正在执行的循环并跳到循环外执行下一条语句。if 是流程选择用法。awk中，流程控制语句，语法结构，与c语言类型。有了这些语句，其实很多shell程序都可以交给awk，而且性能是非常快的。下面是各个语句用法。 条件判断语句1234if(表达式) 语句1else 语句2 格式中语句1可以是多个语句，为了方便判断和阅读，最好将多个语句用{}括起来。awk分枝结构允许嵌套，其格式为： 123456if(表达式) &#123;语句1&#125;else if(表达式) &#123;语句2&#125;else &#123;语句3&#125; 示例： 1234567891011121314awk &#x27;BEGIN&#123;test=100;if(test&gt;90)&#123; print &quot;very good&quot;; &#125; else if(test&gt;60)&#123; print &quot;good&quot;; &#125; else&#123; print &quot;no pass&quot;; &#125;&#125;&#x27;very good 每条命令语句后面可以用; 分号 结尾。 循环语句while语句12while(表达式) &#123;语句&#125; 示例： 12345678910awk &#x27;BEGIN&#123;test=100;total=0;while(i&lt;=test)&#123; total+=i; i++;&#125;print total;&#125;&#x27;5050 for循环for循环有两种格式： 格式1： 12for(变量 in 数组) &#123;语句&#125; 示例： 1234567891011121314awk &#x27;BEGIN&#123;for(k in ENVIRON)&#123; print k&quot;=&quot;ENVIRON[k];&#125;&#125;&#x27;TERM=linuxG_BROKEN_FILENAMES=1SHLVL=1pwd=/root/text...logname=rootHOME=/rootSSH_CLIENT=192.168.1.21 53087 22 注：ENVIRON是awk常量，是子典型数组。 格式2： 12for(变量;条件;表达式) &#123;语句&#125; 示例： 12345678awk &#x27;BEGIN&#123;total=0;for(i=0;i&lt;=100;i++)&#123; total+=i;&#125;print total;&#125;&#x27;5050 do循环12do&#123;语句&#125; while(条件) 例子： 1234567awk &#x27;BEGIN&#123; total=0;i=0;do &#123;total+=i;i++;&#125; while(i&lt;=100) print total;&#125;&#x27;5050 其他语句 break 当 break 语句用于 while 或 for 语句时，导致退出程序循环。 continue 当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代。 next 能能够导致读入下一个输入行，并返回到脚本的顶部。这可以避免对当前输入行执行其他的操作过程。 exit 语句使主输入循环退出并将控制转移到END,如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行。 数组应用数组是awk的灵魂，处理文本中最不能少的就是它的数组处理。因为数组索引（下标）可以是数字和字符串在awk中数组叫做关联数组(associative arrays)。awk 中的数组不必提前声明，也不必声明大小。数组元素用0或空字符串来初始化，这根据上下文而定。 数组的定义数字做数组索引（下标）： 12Array[1]=&quot;sun&quot;Array[2]=&quot;kai&quot; 字符串做数组索引（下标）： 123Array[&quot;first&quot;]=&quot;www&quot;Array&quot;[last&quot;]=&quot;name&quot;Array[&quot;birth&quot;]=&quot;1987&quot; 使用中print Array[1]会打印出sun；使用print Array[2]会打印出kai；使用print[&quot;birth&quot;]会得到1987。 读取数组的值 12&#123; for(item in array) &#123;print array[item]&#125;; &#125; #输出的顺序是随机的&#123; for(i=1;i&lt;=len;i++) &#123;print array[i]&#125;; &#125; #Len是数组的长度 数组相关函数 得到数组长度： 12awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;lens=split(info,tA,&quot; &quot;);print length(tA),lens;&#125;&#x27;4 4 length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。 12awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);print asort(tA);&#125;&#x27;4 asort对数组进行排序，返回数组长度。 输出数组内容（无序，有序输出）： 12345awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;split(info,tA,&quot; &quot;);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;4 test1 it2 is3 a for…in输出，因为数组是关联数组，默认是无序的。所以通过for…in得到是无序的数组。如果需要得到有序数组，需要通过下标获得。 12345awk &#x27;BEGIN&#123;info=&quot;it is a test&quot;;tlen=split(info,tA,&quot; &quot;);for(k=1;k&lt;=tlen;k++)&#123;print k,tA[k];&#125;&#125;&#x27;1 it2 is3 a4 test 注意：数组下标是从1开始，与C数组不一样。 判断键值存在以及删除键值： 123456#错误的判断方法：awk &#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if(tB[&quot;c&quot;]!=&quot;1&quot;)&#123;print &quot;no found&quot;;&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27; no founda a1b b1c 以上出现奇怪问题，tB[“c”]没有定义，但是循环时候，发现已经存在该键值，它的值为空，这里需要注意，awk数组是关联数组，只要通过数组引用它的key，就会自动创建改序列。 1234#正确判断方法：awk &#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;if( &quot;c&quot; in tB)&#123;print &quot;ok&quot;;&#125;;for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27; a a1b b1 if(key in array)通过这种方法判断数组中是否包含key键值。 123#删除键值：[chengmo@localhost ~]$ awk &#x27;BEGIN&#123;tB[&quot;a&quot;]=&quot;a1&quot;;tB[&quot;b&quot;]=&quot;b1&quot;;delete tB[&quot;a&quot;];for(k in tB)&#123;print k,tB[k];&#125;&#125;&#x27; b b1 delete array[key]可以删除，对应数组key的，序列值。 二维、多维数组使用awk的多维数组在本质上是一维数组，更确切一点，awk在存储上并不支持多维数组。awk提供了逻辑上模拟二维数组的访问方式。例如，array[2,4]=1这样的访问是允许的。awk使用一个特殊的字符串SUBSEP(�34)作为分割字段，在上面的例子中，关联数组array存储的键值实际上是2�344。 类似一维数组的成员测试，多维数组可以使用if ( (i,j) in array)这样的语法，但是下标必须放置在圆括号中。类似一维数组的循环访问，多维数组使用for ( item in array )这样的语法遍历数组。与一维数组不同的是，多维数组必须使用split()函数来访问单独的下标分量。 123456789101112131415161718awk &#x27;BEGIN&#123;for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; print i,&quot;*&quot;,j,&quot;=&quot;,tarr[i,j]; &#125;&#125;&#125;&#x27;1 * 1 = 11 * 2 = 21 * 3 = 31 * 4 = 41 * 5 = 51 * 6 = 6 ...9 * 6 = 549 * 7 = 639 * 8 = 729 * 9 = 81 可以通过array[k,k2]引用获得数组内容。 另一种方法： 12345678910awk &#x27;BEGIN&#123;for(i=1;i&lt;=9;i++)&#123; for(j=1;j&lt;=9;j++)&#123; tarr[i,j]=i*j; &#125;&#125;for(m in tarr)&#123; split(m,tarr2,SUBSEP); print tarr2[1],&quot;*&quot;,tarr2[2],&quot;=&quot;,tarr[m];&#125;&#125;&#x27; 内置函数awk内置函数，主要分以下3种类似：算数函数、字符串函数、其它一般函数、时间函数。 算术函数 格式 描述 atan2( y, x ) 返回 y&#x2F;x 的反正切。 cos( x ) 返回 x 的余弦；x 是弧度。 sin( x ) 返回 x 的正弦；x 是弧度。 exp( x ) 返回 x 幂函数。 log( x ) 返回 x 的自然对数。 sqrt( x ) 返回 x 平方根。 int( x ) 返回 x 的截断至整数的值。 rand( ) 返回任意数字 n，其中 0 &lt;&#x3D; n &lt; 1。 srand( [expr] ) 将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 举例说明： 123awk &#x27;BEGIN&#123;OFMT=&quot;%.3f&quot;;fs=sin(1);fe=exp(10);fl=log(10);fi=int(3.1415);print fs,fe,fl,fi;&#125;&#x27;0.841 22026.466 2.303 3 OFMT 设置输出数据格式是保留3位小数。 获得随机数： 123456awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;78awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;31awk &#x27;BEGIN&#123;srand();fr=int(100*rand());print fr;&#125;&#x27;41 字符串函数 格式 描述 gsub( Ere, Repl, [ In ] ) 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &amp;（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 index( String1, String2 ) 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 length [(String)] 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 blength [(String)] 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 substr( String, M, [ N ] ) 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 match( String, Ere ) 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 tolower( String ) 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 toupper( String ) 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 sprintf(Format, Expr, Expr, . . . ) 根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 注：Ere都可以是正则表达式。 gsub,sub使用 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;gsub(/[0-9]+/,&quot;!&quot;,info);print info&#125;&#x27;this is a test!test! 在 info中查找满足正则表达式，/[0-9]+/ 用””替换，并且替换后的值，赋值给info 未给info值，默认是$0 查找字符串（index使用） 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;ok 未找到，返回0 正则表达式匹配查找(match使用） 12awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print match(info,/[0-9]+/)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#x27;ok 截取字符串(substr使用） 12[wangsl@centos5 ~]$ awk &#x27;BEGIN&#123;info=&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#x27;s is a tes 从第 4个 字符开始，截取10个长度字符串 字符串分割（split使用） 123456awk &#x27;BEGIN&#123;info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;44 test1 this2 is3 a 分割info，动态创建数组tA，这里比较有意思，awk for …in循环，是一个无序的循环。 并不是从数组下标1…n ，因此使用时候需要注意。 格式化字符串输出（sprintf使用） 格式化字符串格式： 其中格式化字符串包括两部分内容：一部分是正常字符，这些字符将按原样输出; 另一部分是格式化规定字符，以&quot;%&quot;开始，后跟一个或几个规定字符,用来确定输出内容格式。 格式 描述 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 自动选择合适的表示法 12awk &#x27;BEGIN&#123;n1=124.113;n2=-1.224;n3=1.2345; printf(&quot;%.2f,%.2u,%.2g,%X,%on&quot;,n1,n2,n3,n1,n1);&#125;&#x27;124.11,18446744073709551615,1.2,7C,174 一般函数 格式 描述 close( Expression ) 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的。 system(command ) 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程。 Expression getline [ Variable ] getline [ Variable ] &lt; Expression 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录。 getline [ Variable ] 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量。 打开外部文件（close用法） 1234awk &#x27;BEGIN&#123;while(&quot;cat /etc/passwd&quot;|getline)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin 逐行读取外部文件(getline使用方法） 1234awk &#x27;BEGIN&#123;while(getline &lt; &quot;/etc/passwd&quot;)&#123;print $0;&#125;;close(&quot;/etc/passwd&quot;);&#125;&#x27;root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin 1234awk &#x27;BEGIN&#123;print &quot;Enter your name:&quot;;getline name;print name;&#125;&#x27;Enter your name:chengmochengmo 调用外部应用程序(system使用方法） 1234awk &#x27;BEGIN&#123;b=system(&quot;ls -al&quot;);print b;&#125;&#x27;total 42092drwxr-xr-x 14 chengmo chengmo 4096 09-30 17:47 .drwxr-xr-x 95 root root 4096 10-08 14:01 .. b返回值，是执行结果。 时间函数 格式 描述 函数名 说明 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式 strftime([format [, timestamp]]) 格式化时间输出，将时间戳转为时间字符串 具体格式，见下表. systime() 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 建指定时间(mktime使用） 12awk &#x27;BEGIN&#123;tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print strftime(&quot;%c&quot;,tstamp);&#125;&#x27;2001年01月01日 星期一 12时12分12秒 12awk &#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=mktime(&quot;2001 02 01 0 0 0&quot;);print tstamp2-tstamp1;&#125;&#x27;2634468 求2个时间段中间时间差，介绍了strftime使用方法 12awk &#x27;BEGIN&#123;tstamp1=mktime(&quot;2001 01 01 12 12 12&quot;);tstamp2=systime();print tstamp2-tstamp1;&#125;&#x27; 308201392 strftime日期和时间格式说明符 格式 描述 %a 星期几的缩写(Sun) %A 星期几的完整写法(Sunday) %b 月名的缩写(Oct) %B 月名的完整写法(October) %c 本地日期和时间 %d 十进制日期 %D 日期 08&#x2F;20&#x2F;99 %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的小时 %I 用十进制表示12小时格式的小时 %j 从1月1日起一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法(AM&#x2F;PM) %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期(星期天作为一个星期的开始) %w 十进制表示的星期几(星期天是0) %W 十进制表示的一年中的第几个星期(星期一作为一个星期的开始) %x 重新设置本地日期(08&#x2F;20&#x2F;99) %X 重新设置本地时间(12：00：00) %y 两位数字表示的年(99) %Y 当前月份 %Z 时区(PDT) %% 百分号(%)","tags":["Awk","linux","unix","文本处理"],"categories":["技术","学习笔记"]},{"title":"详细解析一下Pjax的原理","path":"/post/17/","content":"之前我写过一篇Pjax相关的文章，但是特别水，基本上只讲了简单的调用方法，所以有站右私信我说，想给他自己网站安排上，但是我出的教程又太水了问网能不能详细点，于是我就写了这篇文章，详细讲解一下Pjax页面无刷新加载的原理，当然也算自己的一点学习了想水文章就直接说 之前写的文章看这里：https://www.mengze2.cn/post/6/ 什么是PjaxPjax（PushState + Ajax）是一种前端技术，旨在提高网页的加载速度与用户体验。它通过结合 AJAX 和浏览器的历史管理功能（PushState），实现局部更新页面内容，而无需整个页面的刷新，这也就几乎完全实现了“沉浸式阅读”，还能提高页面加载速度。 Pjax最初是由 GitHub 的工程师 Dave Ward 开发的，首次发布于 2011年。它的主要目的是为了解决传统页面加载带来的性能问题，提供一种无刷新更新页面内容的方式。 目前，Pjax的维护和开发已经转移到开源社区，GitHub上有多个相关的实现和版本。最常用的Pjax库是 “jquery-pjax”，这个库在GitHub上仍然有活跃的贡献者和维护者，用户可以根据需要对其进行使用和修改。 它的原理Pjax允许在用户点击链接时拦截默认的页面加载行为，通过异步请求获取新的内容并更新页面，同时使用history.pushState()更新浏览器地址栏的URL，从而实现无刷新地更新网页内容，提升用户体验并保持浏览器的历史记录功能，使得用户能够顺畅地在不同内容之间导航而无需重新加载整个页面。 Pjax有两个核心组件，分别是AJAX和PushState 实际上，Pjax的工作流程非常简单 拦截链接点击事件： 使用JavaScript拦截用户点击的链接（&lt;a&gt;标签）。 检查链接是否支持Pjax（例如，是否有特定的类名或属性）。 发送Ajax请求： 通过Ajax请求获取目标页面的内容。 请求通常是一个HTTP GET请求，URL为用户点击的链接的URL。 更新页面内容： 在Ajax请求成功后，获取返回的HTML内容。 提取需要更新的部分（一般是一个特定的容器，如&lt;div id=&quot;content&quot;&gt;）。 将提取的内容替换当前页面中的相应部分。 更新浏览器历史记录： 使用history.pushState或history.replaceState API更新浏览器的地址栏URL，确保用户可以使用浏览器的后退和前进按钮。 原理知道了还不知道怎么调用Pjax和给全站安排上吗? 这里推荐用CDN引入，因为快 12&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js&quot;&gt;&lt;/script&gt; 然后JavaScript中加上 1$(document).pjax(&#x27;a.pjax&#x27;, &#x27;#content&#x27;); 就完成了。","tags":["Pjax","页面无刷新加载"],"categories":["技术"]},{"title":"慢，是一种生活节奏","path":"/post/16/","content":"慢是一种节奏，慢不会停下脚步，而是调整心态，从容面对生活。 慢下来，感受生活的美好。或许路途遥远，但每一步都值得。 或许每个人心中都有一片属于自己的净土，那里没有纷扰，只有宁静和安宁。当我仿佛迷失在茫茫人海中时，我会闭上双眼，聆听内心的声音，寻找那份最初的热爱。那是一种慢慢生长的力量，如同阳光下成长的小草，虽然微弱，却拥有无穷的生命力。正是这份力量支撑着我，在迷茫中坚定前行。 有人说，生活是一场马拉松，而非短跑比赛。在这场漫长的旅途中，我们需要学会调整呼吸，找到自己的节奏。或许我们总是追逐梦想的光芒，却忽略了脚下的每一步。慢下来，品味路途中的风景，感知阳光洒落的温暖，聆听风吹过树梢的声音。每一次的坚持都是一种沉淀，是一种对生活最真实的态度。 或许我们总是被忙碌的生活所累，但是当我们抬头仰望星空，才发现自己是多么渺小。我们需要的不仅仅是在路上匆匆前行，更需要的是停下脚步，审视内心深处的期许。不要害怕迷失，因为只有迷失过，才能找到更真实的自己。在这条漫长的路上，或许我们会受伤、会流泪，但正是这些伤痕和泪水，让我们更加坚强，更加明白自己的方向。每一个瞬间都是生命的奇迹，每一次坚持都是心灵的升华。慢下来，感受生活的温度，用心感知身边的美好。或许梦想的道路上会有风急雨骤，但只要我们心中依然燃烧着热爱的火焰，就不会畏惧任何困难。慢慢地走，慢慢地看，慢慢地听，我们会发现生活中处处都是风景，只要用心去感受。 所以，让我们学会慢下来，不为外界的喧嚣所扰，不为表面的浮华所迷惑，用心去体味生活的细腻。在这个瞬息万变的世界里，保持一颗平静的心，将会是我们最好的选择。慢慢来，一切都会有答案。","tags":["生活","慢节奏"],"categories":["技术"]},{"title":"近况-2024/09/02","path":"/post/15/","content":"也不知道是什么时候了，我博客从Typecho换到了Hexo，自上次彗星云跑路之后我好像就没买过云产品了，一直在学习Github相关的和折腾Github Pages。也感谢开往群地各位的帮助啦。 三个月时间啥都没干，颓废了。 2024年6月22号，我从宏手里接手了，最开始的理念只是提供一个玩家联机的平台，在梦泽接手之后，服务器从模组服发展到插件服，并由最开始的20几个人发展到现在119个人。具体看官网：astro.mengze2.cn 七月期间的事情大多记不得了 2024年7月1号，彗星云正式跑路，我开始考虑去路。 2024年7月6号，域名备案失败。 2024年7月22号，梦泽导航网停止运营。 2024年8月1号，我在我服务器里面开启了建军节活动。 2024年8月20号，我把我的博客从Typecho切换到了Hexo程序，自后面之后我就再也不怕网站没办法运营了。 2024年8月22号，完善博客主题。 2024年8月25号，我站正式被baidu搜索引擎首页双收。 2024年8月27号，我搭建了一个免费ai聊天网站，并支持ChatGPT-4o-mini模型。 2024年8月29号，我给我的博客安排上了Github Action自动化部署。具体看文章：https://www.mengze2.cn/post/10/ 2024年8月30号，我使用PHP和AES-265算法写了个文本加解密工具，并开源。具体看文章：https://www.mengze2.cn/post/12/ 2024年9月1号，大家都在开学の时间，我给我博客安装上了友链朋友圈极简版。链接：https://www.mengze2.cn/post/10/","tags":["近况","Minecraft","折腾","学习"],"categories":["技术","记录"]},{"title":"Docker安装MySQL及MySQL学习","path":"/post/14/","content":"Docker是一个开源的容器化管理平台，可以方便部署各种WEB&#x2F;APP应用依赖环境，很多人用它来部署MySQL数据库管理。 安装Docker在此之前需要安装Docker容器，这里不多说了，可以去菜鸟教程根据教程安装Docker 拉取MySQL镜像部署好Docker之后要开始拉取MySQL的镜像文件，前往Docker输入以下命令： 1docker pull mysql 这会从Docker拉取MySQL的镜像，可以使用以下命令查看已拉取的镜像列表 1docker images 启动容器在拉取完成之后，可以使用命令行启动MySQL的镜像容器 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:latest 这这命令会在后台启动MySQL容器，并将其命名为“some-mysql”。此外，您需要设置MySQL的root密码，以便在后续的步骤中进行访问。 连接MySQL启动容器后，需要连接至MySQL，可以使用docker命令连接MySQL 1docker exec -it some-mysql mysql -p 此命令将连接到MySQL容器，并要求您输入root密码。输入您在步骤3中设置的密码即可登录MySQL。 开始使用Docker版MySQL现在，您已经成功地使用Docker安装和启动了MySQL容器。您可以使用常规的MySQL命令进行数据库管理，因为Docker版MySQL和普通版基本一样，例如，您可以使用以下命令创建一个新的数据库： 1CREATE DATABASE 数据库名 DDL（数据定义语言）学习当我们想要创建一个新的MySQL表时，我们需要使用DDL（数据定义语言）来定义表的结构。DDL包括创建表，修改表和删除表等操作。 创建库基本语法在MySQL中，可以使用CREATE DATABASE语句来创建一个新的数据库。它的基本语法如下： 1CREATE DATABASE database_name; 其中，database_name是要创建的数据库的名称。例如，要创建一个名为mydatabase的新数据库，可以使用以下查询： 1CREATE DATABASE mydatabase; 需要注意的是，创建数据库的用户必须具有足够的权限。如果当前用户没有创建数据库的权限，可以使用以下查询来授权： 1GRANT CREATE ON *.* TO &#x27;user&#x27;@&#x27;localhost&#x27;; 这个查询将授予user用户在本地主机上创建数据库的权限。在创建数据库后，可以使用USE语句来选择要使用的数据库。例如，要使用mydatabase数据库，可以使用以下查询： 1USE mydatabase; 这个查询将选择mydatabase数据库，并将其设置为当前数据库。在选择数据库后，可以使用其他SQL语句来创建表、插入数据、查询数据等。 命名在MySQL中，数据库名必须遵循以下规则：数据库名必须以字母开头，可以包含字母、数字和下划线。数据库名不能超过64个字符。数据库名区分大小写。数据库名不能与MySQL保留关键字相同，例如SELECT、INSERT、UPDATE等。需要注意的是，虽然MySQL允许使用特殊字符和空格作为数据库名，但这并不是一个好的做法，因为它可能会导致一些问题。为了避免这些问题，最好只使用字母、数字和下划线作为数据库名。另外，建议在命名数据库时使用有意义的名称，以便更好地描述数据库的内容和用途。例如，如果数据库用于存储客户信息，可以将其命名为customers。这样做可以使数据库更易于管理和维护。 字符集在MySQL中，字符集用于定义数据库中存储的字符集和排序规则。MySQL支持多种字符集，包括ASCII、UTF-8、GBK等。在创建数据库时，可以指定要使用的字符集。如果没有指定字符集，则使用默认字符集。要查看MySQL中可用的字符集，可以使用以下查询： 1SHOW CHARACTER SET; 要查看当前数据库的字符集，可以使用以下查询： 1SELECT @@character_set_database; 要创建一个使用特定字符集的数据库，可以在CREATE DATABASE语句中指定字符集。例如，要创建一个使用UTF-8字符集的数据库，可以使用以下查询： 1CREATE DATABASE mydatabase CHARACTER SET utf8; 排序规则在MySQL中，排序规则用于定义字符串比较的方式。MySQL支持多种排序规则，包括二进制排序、不区分大小写排序、区分大小写排序等。在创建数据库时，可以指定要使用的排序规则。如果没有指定排序规则，则使用默认排序规则。要查看MySQL中可用的排序规则，可以使用以下查询： 1SHOW COLLATION; 使用以下命令查看当前数据库排序规则： 1SELECT @collation_database; 要创建一个使用特定排序规则的数据库，可以在CREATE DATABASE语句中指定排序规则。例如，要创建一个使用不区分大小写排序的数据库，可以使用以下查询： 1CREATE DATABASE mydatabase COLLATE utf8_general_ci; 创建表基本语法在MySQL中，用于创建表的关键字是CREATE TABLE。使用CREATE TABLE语句可以创建一个新的表，并指定表的名称、列名、数据类型、约束等信息。以下是一个简单的CREATE TABLE语句示例： 12345CREATE TABLE mytable ( id INT, name VARCHAR(50), age INT); 这个语句将创建一个名为mytable的新表，包含三个列：id、name和age。其中，id和age列的数据类型为整数，name列的数据类型为可变长度的字符串。在CREATE TABLE语句中，还可以指定列的约束，如主键、唯一性约束、非空约束等。例如，要在id列上定义主键约束，可以使用以下语句： 12345CREATE TABLE mytable ( id INT PRIMARY KEY, name VARCHAR(50), age INT); 这个语句将在id列上定义主键约束，保证表中每行数据的唯一性。除了列的约束外，还可以在CREATE TABLE语句中指定表的字符集、排序规则等信息。例如，要创建一个使用UTF-8字符集和不区分大小写排序的表，可以使用以下语句： 12345CREATE TABLE mytable ( id INT, name VARCHAR(50), age INT) CHARACTER SET utf8 COLLATE utf8_general_ci; 这个语句将创建一个使用UTF-8字符集和不区分大小写排序的新表。需要注意的是，在创建表时，应根据实际情况选择适当的数据类型、约束、字符集和排序规则，以确保表的正确性和性能。同时也可以使用AUTO_INCREMENT关键字来创建自增列。自增列是一种特殊的列，它的值会自动递增，每次插入新行时都会自动分配一个新的值。以下是一个使用AUTO_INCREMENT关键字创建自增列的示例： 12345CREATE TABLE mytable ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), age INT); 这个语句将创建一个名为mytable的新表，包含三个列：id、name和age。其中，id列使用AUTO_INCREMENT关键字定义为自增列，并将其设置为主键。在插入新行时，可以省略id列的值，MySQL会自动分配一个新的值。例如，要插入一行数据，可以使用以下语句： 1INSERT INTO mytable (name, age) VALUES (&#x27;John&#x27;, 30); 这个语句将插入一行数据，id列的值会自动递增。需要注意的是，自增列只能用于整数类型的列，且每个表只能有一个自增列。在创建表时，应根据实际情况选择是否需要使用自增列。如果表中的数据不需要自动递增的唯一标识符，可以不使用自增列。 数据类型在MySQL中，有多种数据类型可用于创建表中的列。以下是一些常用的MySQL数据类型：INT或INTEGER：用于存储整数。FLOAT或DOUBLE：用于存储浮点数。DECIMAL：用于存储精确的小数。VARCHAR：用于存储可变长度的字符串。CHAR：用于存储固定长度的字符串。TEXT：用于存储较长的文本数据。DATE：用于存储日期。TIME：用于存储时间。DATETIME：用于存储日期和时间。TIMESTAMP：用于存储时间戳。BOOLEAN或BOOL：用于存储布尔值。除了这些常用的数据类型外，MySQL还支持其他一些数据类型，如枚举、集合、二进制数据等。在创建表时，可以根据需要选择适当的数据类型。需要注意的是，不同的数据类型具有不同的存储要求和限制，因此应根据实际情况选择合适的数据类型。 索引在MySQL中，索引是一种用于加速数据检索的数据结构。索引可以提高查询效率，减少查询所需的时间和资源。MySQL支持多种类型的索引，包括B-tree索引、哈希索引、全文索引等。以下是一些常用的MySQL索引:PRIMARY KEY：用于定义表的主键，可以保证表中每行数据的唯一性。UNIQUE：用于定义唯一性约束，可以保证列中的值唯一。INDEX：用于创建普通索引，可以加速查询。FULLTEXT：用于创建全文索引，可以加速全文检索。在创建表时，可以在列上定义索引。例如，要在id列上创建主键索引，可以使用以下查询： 1234CREATE TABLE mytable ( id INT PRIMARY KEY, name VARCHAR(50)); 要在name列上创建唯一性约束，可以使用以下查询： 1234CREATE TABLE mytable ( id INT, name VARCHAR(50) UNIQUE); 要在name列上创建普通索引，可以使用以下查询： 12345CREATE TABLE mytable ( id INT, name VARCHAR(50), INDEX name_index (name)); 要在content列上创建全文索引，可以使用以下查询： 12345CREATE TABLE mytable ( id INT, content TEXT, FULLTEXT content_index (content)); 需要注意的是，索引可以提高查询效率，但也会增加数据插入、更新和删除的时间和资源消耗。因此，在创建索引时，应根据实际情况选择适当的索引类型和列。 修改表如果我们想要修改现有的表结构，我们可以使用ALTER TABLE语句。以下是一些常见的ALTER TABLE操作： 添加列要在表中添加新列，我们可以使用以下语法： 1234567ALTER TABLE users ADD COLUMN birthdate DATE;`````在上面的示例中，我们向“users”表中添加了一个名为“birthdate”的列。#### 修改列要修改现有列的定义，我们可以使用以下语法：````MYSQLALTER TABLE users MODIFY COLUMN email VARCHAR(200); 在上面的示例中，我们将“users”表中的“email”列长度从100修改为200。删除列要删除表中的列，我们可以使用以下语法： 1ALTER TABLE users DROP COLUMN email; 在上面的示例中，我们从“users”表中删除了名为“email”的列。 删除表如果我们想要删除表，我们可以使用以下语句： 1DROP TABLE users; 在上面的示例中，我们删除了名为“users”的表。总之，DDL是MySQL中重要的语言，用于定义和修改表结构。它使我们能够创建，修改和删除表，以及添加，修改和删除表中的列 DML(数据操纵语言)学习当我们需要对MySQL数据库中的数据进行操作时，我们可以使用数据操作语言（DML）。DML包括SELECT、INSERT、UPDATE和DELETE语句。 SELECT语句SELECT语句用于从MySQL数据库中检索数据。它的基本语法如下： 1SELECT column1, column2, ... FROM table_name WHERE condition; 其中，column1, column2, …是要查询的列名，table_name是要查询的表名，condition是查询条件。 例如，要查询customers表中的所有数据，可以使用以下查询： 1SELECT * FROM customers; WHERE用于指定查询条件。它的基本语法如下： 1SELECT column1, column2, ... FROM table_name WHERE condition; 其中，condition是查询条件。 例如，要查询customers表中姓氏为Smith的客户，可以使用以下查询： 1SELECT * FROM customers WHERE last_name = &#x27;Smith&#x27;; ORDER BY用于按照指定的列对查询结果进行排序。它的基本语法如下： 1SELECT column1, column2, ... FROM table_name ORDER BY column1 [ASC|DESC]; 其中，column1是要排序的列名，ASC表示升序排序，DESC表示降序排序。 例如，要按照客户的姓氏对customers表进行升序排序，可以使用以下查询： 1SELECT * FROM customers ORDER BY last_name ASC; GROUP BY用于将查询结果按照指定的列进行分组，并对每个分组进行聚合计算。它的基本语法如下： 1234SELECT column1, column2, ..., aggregate_function(column)FROM table_nameWHERE conditionGROUP BY column1, column2, ...; 其中，column1, column2, …是要分组的列名，aggregate_function(column)是要对每个分组进行的聚合计算，例如SUM(column)、AVG(column)、COUNT(column)等。 例如，要按照客户的国家对orders表进行分组，并计算每个国家的订单总数，可以使用以下查询： 123SELECT country, COUNT(*) as total_ordersFROM ordersGROUP BY country; 这个查询将orders表按照国家进行分组，并对每个分组计算订单总数。查询结果将包含每个国家的名称和订单总数。 需要注意的是，GROUP BY语句必须放在WHERE语句之后，而聚合函数必须放在SELECT语句中。在分组时，只能使用SELECT语句中指定的列和聚合函数，而不能使用其他列。 INSERT语句INSERT INTO用于向数据库中插入新数据。它的基本语法如下： 1INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...); 其中，table_name是要插入数据的表名，column1, column2, …是要插入数据的列名，value1, value2, …是要插入的数据值。 例如，要向customers表中插入一条新的客户数据，可以使用以下查询： 1INSERT INTO customers (first_name, last_name, email) VALUES (&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;john.doe@example.com&#x27;); UPDATE语句UPDATE用于更新数据库中的数据。它的基本语法如下： 1UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; 其中，table_name是要更新数据的表名，column1 &#x3D; value1, column2 &#x3D; value2, …是要更新的列和值，condition是更新条件。 例如，要将customers表中姓氏为Smith的客户的邮箱地址更新为&#110;&#101;&#x77;&#46;&#x65;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;，可以使用以下查询： 1UPDATE customers SET email = &#x27;new.email@example.com&#x27; WHERE last_name = &#x27;Smith&#x27;; DELETE语句DELETE用于从数据库中删除数据。它的基本语法如下： 1DELETE FROM table_name WHERE condition; 其中，table_name是要删除数据的表名，condition是删除条件。 例如，要从customers表中删除姓氏为Doe的客户，可以使用以下查询： 1DELETE FROM customers WHERE last_name = &#x27;Doe&#x27;; 联表查询在MySQL中，JOIN操作是将两个或多个表中的数据组合在一起的一种方法。JOIN操作可以帮助我们从多个表中检索数据，并将它们组合在一起以便更好地分析和理解数据。 MySQL中有四种不同类型的JOIN操作：LEFT JOIN、RIGHT JOIN、INNER JOIN和FULL JOIN。下面我们将逐一介绍它们的用法和区别。 INNER JOININNER JOIN操作返回两个表中都存在的行。如果一个表中没有与另一个表中的行匹配的行，则不会返回任何数据。 下面是一个INNER JOIN操作的示例： 1234SELECT *FROM table1INNER JOIN table2ON table1.id = table2.id; 在这个例子中，我们将table1和table2两个表连接起来。我们使用ON关键字指定了连接条件，即table1.id &#x3D; table2.id。这意味着我们将根据这个条件将两个表中的数据进行匹配。 LEFT JOINLEFT JOIN操作返回左表中的所有行，以及右表中与左表中的行匹配的行。如果右表中没有与左表中的行匹配的行，则返回NULL值。 下面是一个LEFT JOIN操作的示例： 1234SELECT *FROM table1LEFT JOIN table2ON table1.id = table2.id; 在这个例子中，我们将table1和table2两个表连接起来。我们使用ON关键字指定了连接条件，即table1.id&#x3D; table2.id。这意味着我们将根据这个条件将两个表中的数据进行匹配。 RIGHT JOINRIGHT JOIN操作与LEFT JOIN操作类似，但是它返回右表中的所有行，以及左表中与右表中的行匹配的行。如果左表中没有与右表中的行匹配的行，则返回NULL值。 下面是一个RIGHT JOIN操作的示例： 1234SELECT *FROM table1RIGHT JOIN table2ON table1.id = table2.id; 在这个例子中，我们将table1和table2两个表连接起来。我们使用ON关键字指定了连接条件，table1.id&#x3D; table2.id。这意味着我们将根据这个条件将两个表中的数据进行匹配。 FULL JOINFULL JOIN操作返回两个表中的所有行。如果一个表中没有与另一个表中的行匹配的行，则返回NULL值。 下面是一个FULL JOIN操作的示例： 1234SELECT *FROM table1FULL JOIN table2ON table1.id = table2.id; 在这个例子中，我们将table1和table2两个表连接起来。我们使用ON关键字指定了连接条件，table1.id &#x3D; table2.id。这意味着我们将根据这个条件将两个表中的数据进行匹配 MySQL中的子查询在MySQL中，子查询是一种查询语句，它嵌套在另一个查询语句中。子查询可以帮助我们从一个表中检索数据，并将其用作另一个查询的条件。 MySQL中的子查询可以嵌套多层，每个子查询都可以返回一个结果集，这个结果集可以用作另一个查询的条件。 下面我们将逐一介绍MySQL中子查询的用法和示例。 子查询的基本语法子查询的基本语法如下： 123SELECT column1, column2, ...FROM table1WHERE column_name operator (SELECT column_name FROM table_name WHERE condition); 在这个语法中，我们使用了一个子查询，它嵌套在WHERE子句中。子查询返回一个结果集，这个结果集将用作WHERE子句中的条件。 子查询的示例下面是一个使用子查询的示例： 123SELECT *FROM ordersWHERE customer_id IN (SELECT customer_id FROM customers WHERE country = &#x27;USA&#x27;); 在这个示例中，我们使用了一个子查询，它嵌套在WHERE子句中。子查询返回一个结果集，这个结果集包含了所有来自美国的客户的ID。这个结果集将用作WHERE子句中的条件，以过滤orders表中来自美国的客户的订单。 子查询的类型MySQL中有两种类型的子查询：标量子查询和表子查询。 标量子查询标量子查询返回一个单一的值，这个值可以用作另一个查询的条件。 下面是一个标量子查询的示例： 123SELECT *FROM ordersWHERE order_date &gt; (SELECT MAX(order_date) FROM orders); 在这个示例中，我们使用了一个标量子查询，它返回了orders表中最近的订单日期。这个日期将用作WHERE子句中的条件，以过滤orders表中最近的订单。 表子查询表子查询返回一个结果集，这个结果集可以用作另一个查询的条件。 下面是一个表子查询的示例： 123SELECT *FROM ordersWHERE customer_id IN (SELECT customer_id FROM customers WHERE country = &#x27;USA&#x27;); 在这个示例中，我们使用了一个表子查询，它返回了所有来自美国的客户的ID。这个结果集将用作WHERE子句中的条件，以过滤orders表中来自美国的客户的订单。 MySQL常用函数MySQL是一种常用的关系型数据库管理系统，它提供了许多内置函数来处理和操作数据，包括字符串函数、日期和时间函数、数学函数和聚合函数。 字符串函数CONCATCONCAT函数用于将两个或多个字符串连接在一起。它的语法如下： 1CONCAT(string1, string2, ...) 例如，要将名字和姓氏连接在一起，可以使用以下查询： 12SELECT CONCAT(first_name, &#x27; &#x27;, last_name) AS full_name FROM customers;SUBSTRING SUBSTRING函数用于从字符串中提取子字符串。它的语法如下： 1SUBSTRING(string, start, length) 其中，string是要提取子字符串的字符串，start是子字符串的起始位置，length是子字符串的长度。 例如，要从字符串中提取前5个字符，可以使用以下查询： 12SELECT SUBSTRING(&#x27;Hello, world!&#x27;, 1, 5);REPLACE REPLACE函数用于替换字符串中的子字符串。它的语法如下： 1REPLACE(string, from_string, to_string) 其中，string是要替换子字符串的字符串，from_string是要替换的子字符串，to_string是要替换成的字符串。 例如，要将字符串中的所有空格替换为下划线，可以使用以下查询： 1SELECT REPLACE(&#x27;Hello, world!&#x27;, &#x27; &#x27;, &#x27;_&#x27;); 日期和时间函数NOWNOW函数用于返回当前日期和时间。它的语法如下： 1NOW() 例如，要获取当前日期和时间，可以使用以下查询： 12SELECT NOW();DATE_FORMAT DATE_FORMAT函数用于将日期和时间格式化为指定的字符串。它的语法如下： DATE_FORMATDATE_FORMAT函数用于将日期和时间格式化为指定的字符串。它的语法如下： 1DATE_FORMAT(date, format) 其中，date是要格式化的日期和时间，format是要格式化成的字符串。 例如，要将日期格式化为年-月-日的形式，可以使用以下查询： 1SELECT DATE_FORMAT(NOW(), &#x27;%Y-%m-%d&#x27;); 数学函数ABSABS函数用于返回一个数的绝对值。它的语法如下： 1ABS(number) 例如，要获取-10的绝对值，可以使用以下查询： 1SELECT ABS(-10); ROUNDROUND函数用于将一个数四舍五入到指定的小数位数。它的语法如下： 1ROUND(number, decimals) 其中，number是要四舍五入的数，decimals是要保留的小数位数。 例如，要将3.14159四舍五入到两位小数，可以使用以下查询： 1SELECT ROUND(3.14159, 2); 聚合函数COUNTCOUNT函数用于计算指定列中的行数。它的语法如下： 1COUNT(column) 例如，要计算customers表中的行数，可以使用以下查询： 12SELECT COUNT(*) FROM customers;SUM SUM函数用于计算指定列中的数值总和。它的语法如下： 1SUM(column) 例如，要计算orders表中的总销售额，可以使用以下查询： 12SELECT SUM(total_amount) FROM orders;AVG AVG函数用于计算指定列中的平均值。它的语法如下： 1AVG(column) 例如，要计算orders表中的平均销售额，可以使用以下查询： 1SELECT AVG(total_amount) FROM orders;","tags":["docker","MySQL","DLL","DML"],"categories":["技术"]},{"title":"Typecho插件开发实例及教程","path":"/post/13/","content":"简介Typecho是一款简洁、易用且快速的PHP博客程序，它支持插件扩展，为用户提供了自定义功能的机会。本文将为大家介绍Typecho插件开发的实例和教程，帮助你快速上手开发自己的插件。 准备工作在开始开发Typecho插件之前，我们需要准备以下环境： 一台安装了PHP和MySQL的服务器环境； 下载并安装Typecho博客系统。 确保以上环境已经搭建完成后，我们可以开始插件开发的实例和教程。 示例1：本文由我的 Typecho 插件自动发布现在，我们开始编写一个简单的 Typecho 插件，实现在文章底部添加“本文由我的 Typecho 插件自动发布”这样的一句话。 创建插件目录首先，我们需要在 Typecho 的插件目录中创建一个新的插件目录，用于存放插件相关文件。打开 Typecho 的插件目录（默认为typecho/usr/plugins），在该目录下创建一个名为myPlugin的目录，作为我们的插件目录。 创建插件设置页面接下来，我们需要在myPlugin目录下创建一个名为Plugin.php的文件，用于定义插件基本信息、激活插件和输出插件设置页面等内容。以下是Plugin.php文件的代码： 123456789101112131415161718192021222324252627&lt;?phpclass myPlugin_Plugin implements Typecho_Plugin_Interface&#123; public static function activate() &#123; // 激活插件时执行的操作 &#125; public static function deactivate() &#123; // 禁用插件时执行的操作 &#125; public static function config(Typecho_Widget_Helper_Form $form) &#123; // 插件设置页面，用于配置插件参数 $html = &lt;&lt;&lt;EOF &lt;p&gt;本文由我的 Typecho 插件自动发布&lt;/p&gt;EOF; echo $html; &#125; public static function personalConfig(Typecho_Widget_Helper_Form $form) &#123; // 个人设置页面，用于配置个人参数 &#125;&#125; 其中，activate()方法和deactivate()方法分别表示插件的激活和禁用操作，在这里我们暂时不需要进行任何操作。config()方法用于输出插件设置页面，这里我们只需要输出一句话即可。 注册插件在插件目录下创建Plugin.php文件后，我们还需要在 Typecho 中注册该插件。打开 Typecho 的后台管理界面，在导航栏中点击“控制台”，然后点击“插件”-&gt;“启用”-&gt;“myPlugin”，即可将我们编写的插件注册到 Typecho 中。 输出插件内容经过上述步骤，我们已经完成了 Typecho 插件的开发和注册。现在，我们需要在文章底部输出插件内容。为此，我们需要打开themes/default/post.php文件，找到以下代码： 1&lt;?php $this-&gt;footer(); ?&gt; 在该代码前面添加如下代码： 1&lt;?php Typecho_Plugin::factory(&#x27;myPlugin&#x27;)-&gt;config(); ?&gt; 这样，当用户访问文章页面时，就会在文章底部输出“本文由我的 Typecho 插件自动发布”这句话了。 插件基本信息每个 Typecho 插件都需要包含一个Plugin.php文件，用于定义插件基本信息、激活插件和输出插件设置页面等内容。在Plugin.php文件中，我们需要定义以下基本信息： 12345678910111213141516171819202122class myPlugin_Plugin implements Typecho_Plugin_Interface&#123; public static function activate() &#123; // 激活插件时执行的操作 &#125; public static function deactivate() &#123; // 禁用插件时执行的操作 &#125; public static function config(Typecho_Widget_Helper_Form $form) &#123; // 插件设置页面，用于配置插件参数 &#125; public static function personalConfig(Typecho_Widget_Helper_Form $form) &#123; // 个人设置页面，用于配置个人参数 &#125;&#125; 其中，myPlugin_Plugin表示插件类名，需要根据实际情况进行修改。activate()方法和deactivate()方法分别表示插件的激活和禁用操作，在这里我们暂时不需要进行任何操作。config()方法用于输出插件设置页面，personalConfig()方法用于输出个人设置页面。 插件设置页面Typecho 的插件设置页面需要通过Typecho_Widget_Helper_Form类来生成，具体代码如下： 12345public static function config(Typecho_Widget_Helper_Form $form)&#123; $myOption = new Typecho_Widget_Helper_Form_Element_Text(&#x27;myOption&#x27;, NULL, &#x27;Default&#x27;, _t(&#x27;My Option&#x27;)); $form-&gt;addInput($myOption);&#125; 其中，$myOption表示一个文本输入框，myOption是该输入框的名称，&#39;Default&#39;表示输入框中默认的内容，_t(&#39;My Option&#39;)表示输入框前面显示的标签名称。如果需要添加多个设置项，可以参考上述代码进行修改。 插件激活当用户激活插件时，Typecho 会自动调用activate()方法。在该方法中，我们可以进行一些初始化操作，例如创建数据库表、添加设置项等。例如，以下代码用于在 Typecho 中创建一个新的设置项： 1234567891011121314public static function activate()&#123; $db = Typecho_Db::get(); $prefix = $db-&gt;getPrefix(); $options = Typecho_Widget::widget(&#x27;Widget_Options&#x27;); $options-&gt;plugin(&#x27;myPlugin&#x27;)-&gt;myOption = &#x27;Default&#x27;; $sql = &quot;CREATE TABLE IF NOT EXISTS `&quot; . $prefix . &quot;myPlugin` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4;&quot;; $db-&gt;query($sql);&#125; 在上述代码中，我们先获取了 Typecho 的数据库连接和前缀信息，然后通过Typecho_Widget::widget(&#39;Widget_Options&#39;)方法获取了 Typecho 的设置对象，将默认值存储在其中。接着，我们定义了一个 SQL 语句，用于创建一个新的数据库表。最后，调用$db-&gt;query($sql)执行 SQL 语句即可完成插件激活操作。 插件禁用当用户禁用插件时，Typecho 会自动调用deactivate()方法。在该方法中，我们可以进行一些清理操作，例如删除数据库表等。例如，以下代码用于在 Typecho 中删除之前创建的数据库表： 12345678public static function deactivate()&#123; $db = Typecho_Db::get(); $prefix = $db-&gt;getPrefix(); $sql = &quot;DROP TABLE IF EXISTS `&quot; . $prefix . &quot;myPlugin`;&quot;; $db-&gt;query($sql);&#125; 在上述代码中，我们通过定义一个 SQL 语句来删除之前创建的数据库表。最后，调用$db-&gt;query($sql)执行 SQL 语句即可完成插件禁用操作。 实例2：自定义社交分享按钮插件我们以一个自定义社交分享按钮插件为例，展示Typecho插件开发的实例。 步骤一：创建插件文件夹首先，在Typecho的插件目录下，创建一个名为SocialShare的文件夹，这将是我们插件的根目录。 步骤二：创建插件主文件在SocialShare文件夹下，创建一个名为Plugin.php的文件，作为插件的主文件。 123456789101112131415161718192021222324252627282930313233&lt;?phpclass SocialShare_Plugin implements Typecho_Plugin_Interface&#123; // 插件激活方法 public static function activate() &#123; // TODO: 插件激活时执行的代码 &#125; // 插件禁用方法 public static function deactivate() &#123; // TODO: 插件禁用时执行的代码 &#125; // 插件配置方法 public static function config(Typecho_Widget_Helper_Form $form) &#123; // TODO: 插件配置页面的内容 &#125; // 插件配置保存方法 public static function personalConfig(Typecho_Widget_Helper_Form $form) &#123; // TODO: 插件配置保存时执行的代码 &#125; // 为文章添加自定义字段 public static function render(Typecho_Widget_Helper_Layout $layout) &#123; // TODO: 为文章添加自定义字段的代码 &#125;&#125; 在上述代码中，我们创建了一个SocialShare_Plugin类，并实现了Typecho_Plugin_Interface接口。这个类包含了插件的激活、禁用、配置和渲染等方法。 步骤三：实现插件功能1. 激活插件在SocialShare_Plugin类中，我们需要实现activate方法。在这个方法中，我们可以执行一些在插件激活时需要进行的操作，比如创建数据库表、初始化设置等。 12345678910111213141516171819public static function activate()&#123; // 创建数据库表 $db = Typecho_Db::get(); $prefix = $db-&gt;getPrefix(); $sql = &#x27;CREATE TABLE IF NOT EXISTS `&#x27; . $prefix . &#x27;social_share` ( `cid` INT(10) UNSIGNED NOT NULL, `twitter` VARCHAR(255) DEFAULT NULL, `facebook` VARCHAR(255) DEFAULT NULL, `weibo` VARCHAR(255) DEFAULT NULL, PRIMARY KEY (`cid`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;&#x27;; $db-&gt;query($sql); // 初始化设置 Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;twitter = true; Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;facebook = true; Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;weibo = true;&#125; 在上述代码中，我们创建了一个名为social_share的数据库表，并初始化了一些设置。 2. 禁用插件在SocialShare_Plugin类中，我们需要实现deactivate方法。在这个方法中，我们可以执行一些在插件禁用时需要进行的操作，比如删除数据库表、清理设置等。 12345678910public static function deactivate()&#123; // 删除数据库表 $db = Typecho_Db::get(); $prefix = $db-&gt;getPrefix(); $db-&gt;query(&#x27;DROP TABLE IF EXISTS `&#x27; . $prefix . &#x27;social_share`;&#x27;); // 清理设置 Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;delete();&#125; 在上述代码中，我们删除了之前创建的social_share数据库表，并清理了插件的设置。 3. 配置插件在SocialShare_Plugin类中，我们需要实现config方法和personalConfig方法。这两个方法分别用于显示插件的配置页面和保存配置。 1234567891011121314151617181920public static function config(Typecho_Widget_Helper_Form $form)&#123; // 创建表单 $twitter = new Typecho_Widget_Helper_Form_Element_Checkbox(&#x27;twitter&#x27;, array(&#x27;twitter&#x27; =&gt; &#x27;显示Twitter分享按钮&#x27;), null, &#x27;显示Twitter分享按钮&#x27;); $form-&gt;addInput($twitter); $facebook = new Typecho_Widget_Helper_Form_Element_Checkbox(&#x27;facebook&#x27;, array(&#x27;facebook&#x27; =&gt; &#x27;显示Facebook分享按钮&#x27;), null, &#x27;显示Facebook分享按钮&#x27;); $form-&gt;addInput($facebook); $weibo = new Typecho_Widget_Helper_Form_Element_Checkbox(&#x27;weibo&#x27;, array(&#x27;weibo&#x27; =&gt; &#x27;显示微博分享按钮&#x27;), null, &#x27;显示微博分享按钮&#x27;); $form-&gt;addInput($weibo);&#125;public static function personalConfig(Typecho_Widget_Helper_Form $form)&#123; // 保存配置 Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;twitter = $form-&gt;twitter-&gt;value; Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;facebook = $form-&gt;facebook-&gt;value; Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;)-&gt;weibo = $form-&gt;weibo-&gt;value;&#125; 在上述代码中，我们创建了一个配置表单，可以通过勾选来选择是否显示不同的社交分享按钮。 4. 渲染插件在SocialShare_Plugin类中，我们需要实现render方法。这个方法用于在文章编辑页面中添加自定义字段，以便用户可以设置每篇文章的社交分享按钮。 1234567891011121314public static function render(Typecho_Widget_Helper_Layout $layout)&#123; $options = Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;SocialShare&#x27;); $socialShare = new Typecho_Widget_Helper_Form_Element_Checkbox(&#x27;socialShare&#x27;, array( &#x27;twitter&#x27; =&gt; &#x27;Twitter&#x27;, &#x27;facebook&#x27; =&gt; &#x27;Facebook&#x27;, &#x27;weibo&#x27; =&gt; &#x27;微博&#x27; ), null, &#x27;选择社交分享按钮&#x27; ); $layout-&gt;addItem($socialShare-&gt;multiMode());&#125; 在上述代码中，我们创建了一个多选框，其中包含了Twitter、Facebook和微博三个选项，用户可以根据需要选择需要显示的社交分享按钮。 步骤四：启用插件完成以上步骤后，我们需要在Typecho后台启用插件。登录Typecho后台管理界面，在”控制台”-&gt;”插件”中找到SocialShare插件，并点击”启用”按钮。","tags":["PHP","Typecho","插件开发","Typecho插件"],"categories":["技术"]},{"title":"用PHP和AES-265算法写了一个文本加解密工具","path":"/post/12/","content":"TextAes这是一个使用PHP+composer编写的数据加解密工具，使用 AES-256 算法进行加密和解密。前端页面使用bootstrap。开源地址：https://github.com/MengZe2l/Text-Encryption-and-Decryption-Tools 本地调试&#x2F;无root服务器搭建方法先克隆本仓库，使用如下指令开启PHP预览服务： 1php -S localhost:8000 -t public Nginx搭建方法一在你使用的面板上，新建一个站点，把仓库克隆在站点目录，把运行目录设置成public，然后常规操作就行了 Nginx代理搭建方法二如果你没有面板，可以看着(这是基础模板，需要你自己更改)，克隆本仓库到一个目录，要记住这个目录。找到Nginx配置文件，添加如下Server模块： 123456789101112131415161718192021222324252627282930313233343536373839404142server &#123; listen 443 ssl; # 监听443端口，启用SSL server_name example.com; # 替换为你的网站域名 root 仓库克隆目录/public; index index.php index.html index.htm; ssl_certificate /etc/ssl/certs/cert.crt; # SSL 证书文件路径 ssl_certificate_key /etc/ssl/private/key.key; # SSL 证书私钥文件路径 ssl_protocols TLSv1.2 TLSv1.3; # 支持的 SSL/TLS 协议 ssl_ciphers HIGH:!aNULL:!MD5; # SSL 加密套件 # 根目录请求处理 location / &#123; try_files $uri $uri/ /index.php?$query_string; # 尝试文件存在，如果不存在则交给 index.php 处理 &#125; # 处理 PHP 文件 location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; # 包含 FastCGI 配置 fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # PHP-FPM 的套接字路径，可能需要根据实际情况修改 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 设置脚本文件名参数 include fastcgi_params; # 包含 FastCGI 参数 &#125; # 禁止访问 .ht 文件（通常是 Apache 配置文件） location ~ /\\.ht &#123; deny all; # 拒绝所有对 .ht 文件的访问 &#125; # 可选：添加日志文件用于调试 access_log /var/log/nginx/your-site_access.log; # 访问日志路径 error_log /var/log/nginx/your-site_error.log; # 错误日志路径&#125;# 可选：重定向 HTTP 到 HTTPSserver &#123; listen 80; # 监听80端口 server_name example.com; # 替换为你的网站域名 return 301 https://$host$request_uri; # 重定向所有HTTP请求到HTTPS&#125;","tags":["PHP","数据加密","AES-265","文本加解密","composer"],"categories":["技术"]},{"title":"梦泽带你重温PHP基本-变量","path":"/post/11/","content":"为什么要学习PHP？“我可以用JavaScript来实现程序编写。”但JavaScript的能力是有限的，JavaScript通常运行在浏览器（客户端），它可以制作网页上面的特效：鼠标滑过背景改变颜色，还有网页上常见的鼠标滑过弹出菜单。但如果要让JavaScript实现显示“访问网站的总人数”，它就无能为力了，因为它只能获得客户端的信息，而“访问网站的总人数”是存储在服务器端的。所以就需要另外一种可以在服务器端运行的编程语言，PHP语言就是其中的一种，因为它可以运行在Web服务器端。 变量简介变量时用于储存值的，我们让服务器去干活的时候往往会产生数据，需要临时存放起来，方便取用。 也可以理解为，变量就是一个袋子，里面可以装苹果，凤梨什么的，但是一次只能装一个，装了这个，例外一个就被替换掉了。这可以理解为猴子捡苞谷，捡一个丢一个。 就像这样： 1234567&lt;?php $var = &quot;梦泽全世界最帅&quot;; echo $var;\techo &quot;&lt;br /&gt;&quot;; $var = &quot;梦泽教大家学习PHP&quot;;\techo $var;?&gt; 变量命名规则变量名除了需要“$”进行标识外，还有一些规则需要遵守。就像拿到驾驶证以后，还得遵守交通规则。变量名的命名规则主要有三条： 1、变量名必须以字母或下划线 “_”开头，如”$_name”,”$name” ,”$name2”等，但是”$9name”是不对的。 2、变量名只能由字母、数字、以及“_”组成，还能包含汉字。如”$_qq”,”$qq308” ,”$my_apple”，“比如”$name我等”，但是”$name*”是不对的。 3、变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。 特别需要注意的是，在PHP中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。 变量的数据类型在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），也分成几种数据类型，就像超市商品的包装袋，有几种不同类型，不同的商品使用不同的包装袋。我们可以通过使用“memory_get_usage”获取当前PHP消耗的内存。 123456789101112131415&lt;?php echo $m1 = memory_get_usage(); echo &quot;&lt;br /&gt;&quot;;$var_string = &quot;123&quot;;echo $m2 = memory_get_usage()-$m1; echo &quot;&lt;br /&gt;&quot;;$n=123;echo $m3 = memory_get_usage()-$m1-$m2; echo &quot;&lt;br /&gt;&quot;;$f=123.00;echo $m4 = memory_get_usage()-$m1-$m2-$m3; echo &quot;&lt;br /&gt;&quot;;$var_array = array(&quot;123&quot;);echo $m5 = memory_get_usage()-$m1-$m2-$m3-$m4; ?&gt; 变量的数据类型在PHP中，支持8种原始类型，其中包括四种标量类型、两种复合类型和两种特殊类型。PHP是一门松散类型的语言，不必向PHP声明变量的数据类型，PHP会自动把变量转换为自动的数据类型，一定程度降低了学习PHP的门槛。如果接触过C语言或者JAVA语言，就会发现在声明变量的时候需要声明变量的数据类型。 标量类型—布尔类型布尔类型（boolean）：只有两个值，一个是TRUE，另一个FALSE，可以理解为是或否。它不区分大小写，也就是说”TRUE”和“true”效果是一样的。主要用在条件结构（条件结构在后面部分会介绍）中，例如判断是否满足条件的时候，是用“true”表示满足，用“false”表示不满足。需要注意的是，当我们用”echo”指令输出布尔类型时，如果是“true”则输出的是“1”，“false”则什么也不输出。我们可以使用“var_dump”函数，获取它真正的数据类型。 123&lt;?php $flag=TRUE;?&gt; 标量类型—整型整型（integer）：类似于常见的整数。它可以用十进制、八进制、十六进制指定。十进制就是日常使用的数字；八进制，数字前必须加上“0”(这个0是阿拉伯数字0，可不是英文字母“欧”哦)；十六进制，数字前必须加“0x” (这个0也是阿拉伯数字0，不是“欧”哦)。如： 123456&lt;?php$data_int = 1234; // 十进制数 $data_int = -567; // 一个负数$data_int = 0123; // 八进制数（等于十进制的 83）$data_int = 0x1a; // 十六进制数（等于十进制的 26）?&gt; 标量类型—浮点型浮点型（浮点数、双精度数或实数），也就是通常说的小数，可以用小数点或者科学计数法表示。科学计数法可以使用小写的e，也可以使用大写的E。例如： 12345&lt;?php$num_float = 1.234; //小数点 $num_float = 1.2e3; //科学计数法，小写e $num_float = 7.0E-10; //科学计数法，大写E ?&gt; 标量类型—字符串字符串是由一系列字符组成，在PHP中，字符和字节一样，也就是说，一共有256种不同字符的可能性。字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式。 字串符中遇到引号怎么办 1234567891011121314&lt;?php $str_string1 = &#x27;甲问：&quot;你在哪里学的PHP？&quot;&#x27;;$str_string2 = &quot;乙毫不犹豫地回答：&#x27;当然是梦泽博客咯！&#x27;&quot;;$str_string3 = &#x27;甲问:\\&#x27;能告诉我网址吗？\\&#x27;&#x27;;$str_string4 = &quot;乙答道:\\&quot;www.mengze2.cn\\&quot;&quot;;echo $str_string1;echo &quot;&lt;br /&gt;&quot;;echo $str_string2;echo &quot;&lt;br /&gt;&quot;;echo $str_string3;echo &quot;&lt;br /&gt;&quot;;echo $str_string4;echo &quot;&lt;br /&gt;&quot;;?&gt; 第一种方案：在单引号中嵌入双引号，如上代码第2行所示； 第二种方案：在双引号中嵌入单引号，如代码第3行所示； 第三种方案：使用转义符“\\”(后面部分还有介绍)，分别如上代码第4行和第5行所示； 当引号遇到美元咋办 当双引号中包含变量时，变量会与双引号中的内容连接在一起；当单引号中包含变量时，变量会被当做字符串输出。 12345678&lt;?php $love = &quot;I love you!&quot;; $string1 = &quot;慕课网,$love&quot;;$string2 = &#x27;慕课网,$love&#x27;;echo $string1;echo &quot;&lt;br /&gt;&quot;;echo $string2;?&gt; 字符串很长怎么办 我们可以使用Heredoc结构形式的方法来解决该问题，首先使用定界符表示字符串（&lt;&lt;&lt;），接着在“&lt;&lt;&lt;“之后提供一个标识符GOD，然后是字符串，最后以提供的这个标识符结束字符串。 12345678910&lt;?php $string1 = &lt;&lt;&lt;GOD我有一只小毛驴，我从来也不骑。有一天我心血来潮，骑着去赶集。我手里拿着小皮鞭，我心里正得意。不知怎么哗啦啦啦啦，我摔了一身泥.GOD; echo $string1;?&gt; 特殊类型—资源 资源（resource）：资源是由专门的函数来建立和使用的，例如打开文件、数据连接、图形画布。我们可以对资源进行操作（创建、使用和释放）。任何资源，在不需要的时候应该被及时释放。如果我们忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。 12345&lt;?php$file=fopen(&quot;f.txt&quot;,&quot;r&quot;); //打开文件$con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); //连接数据库$img=imagecreate(100,100);//图形画布?&gt; 特殊类型—空类型 NULL（NULL）：NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，当被赋值为NULL，或者尚未被赋值，或者被unset()，这三种情况下变量被认为为NULL。","tags":["PHP","变量","学习PHP"],"categories":["技术"]},{"title":"给Hexo博客安排上Github Action自动化部署","path":"/post/10/","content":"我不是换hexo了吗，一直是使用Spck Editor写文章，每次写好文章都要push一次，非常麻烦，最近在群友那了解到有Github Action自动化部署，可以写好文章自动部署到github pages，而且github的编辑器也是非常好用的，写好提交就能自动发送，–怎么有点像SSR了–，于是我就开始了这一个半小时的折腾…没有电脑，使用安卓设备折腾！ 如果你没有Hexo博客，那么请看这里，如果有那就请跳过本节新建一个Hexo博客，这里使用ZeroTermux操作。打开ZeroTermux，运行： 1pkg install nodejs 安装完成之后使用 12node -vnpm -v 结果如下或类似即可： 安装并初始化一个博客 1npm install hexo-cli 等待时间可能久一点。 然后 1hexo init 就行了，然后把hexo的目录移动到外部储存的目录，就行了 新建一个仓库去github上新建一个仓库，我这里名字就叫MyHexo，可以随便，要设置成私有仓库。 创建好仓库之后，在本地新建一个文件夹，我这里是手机，使用Spck Editor操作，打开MT管理器，先进入/storage/emulated/0/Android/data/io.spck/files/文件夹，新建一个叫MyHexo的文件夹。 此时，进入你之hexo的目录，或者新建一个hexo博客(待会会讲)，把右边窗口圈住的文件&#x2F;文件夹移动(或者复制)到左边的文件夹，注意！是右边圈出的这些文件！ 然后打开spck editor，刚刚的文件夹名称就是项目名称，按照图片操作 点击版本库图标，初始化版本库 点击添加远端 添加远端 去github那边申请一个key，链接https://github.com/settings/tokens注意！密钥只会显示一遍，记得复制粘贴！ 申请好之后，去spck那边配置。 把文件提交，然后推送。 推送完成之后就该配置Github Action了(此处折腾的时候忘记截图了。 简单说，就是把hexo博客编译前的源代码上传到github代码仓库，Action在代码发生变动的时候，自动通过安装一系列nodejs环境和相关依赖，编译生成html页面到github pages仓库。再简单点说，就是把本地生成博客的工作，全部交给Action执行。好处就是随时随地都能修改或增加博文 ——来自https://isedu.top/ 打开刚刚新建的仓库的Settings-&gt; Secrets and variables -&gt; Actions -&gt; New repository secret， 需要添加三次，分别是GITHUBTOKEN，GITHUBUSERNAME和GITHUBEMAIL 变量名 常量释义 GITHUBMAIL Github 用户邮箱地址 GITHUBTOKEN Github token GITHUBUSERNAME Github 用户名 添加好之后，去Actions-&gt; set up a workflow yourself设置动作流。 复制粘贴如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556name: 自动部署on: push: branches: - master release: types: - publishedjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v2 with: ref: master - name: 安装 Node uses: actions/setup-node@v1 with: node-version: &quot;16.x&quot; - name: 安装 Hexo run: | export TZ=&#x27;Asia/Shanghai&#x27; npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v1 id: cache with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125; - name: 安装依赖 if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: | npm install --save - name: 生成静态文件 run: | hexo clean hexo generate - name: 部署 #此处master:master 指从本地的master分支提交到远程仓库的master分支(不是博客的分支写master即可)，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。 run: | cd ./public git init git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27; git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27; git add . git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot; git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;.github.io.git&quot; master:master # GitHub配置 如果你的本地仓库为main而不是master，那么这样改： 稍作修改之后点击Commit changes… 去你的github pages仓库把pages仓库改成你在上面代码设置的就行了","tags":["Action","Hexo","自动化部署","SSR","SSG"],"categories":["技术"]},{"title":"Android系统下针对Vue@cli环境的部署","path":"/post/3/","content":"前言之前不是发过很多Android系统下安装环境的文章么，但是我发现Nginx和PHP现在都有专门的软件了，比如Ksweb、hopweb编辑器等等等等，但是针对Vue编辑&#x2F;开发&#x2F;预览的环境&#x2F;APP却没有，这里我就来写一篇Android系统下针对Vue@Cli环境的部署仅整活！不要用于生产环境！ Vue@Cli是什么Vue想必大家都知道是什么，但是Vue@Cli是什么呢？这个我之前说过： Vue@Cli是Vue.js官方提供的脚手架工具，它能够帮助我们快速搭建Vue.js项目，并提供了丰富的功能和插件。 缘起看到尤雨溪七年前的微博： 嗬！在手机上也能跑nodejs，有点儿意思哈。 准备首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。 软件一：Termux(ZeroTermux) 软件二：Spck Editor 软件三：一个浏览器(Chromr)还有要带脑子 安装环境打开ZeroTermux更新包列表： 1apt update 安装node.js环境： 1apt install nodejs 输入npm -v查看是否已经安装： 安装Vue@Cli: 1npm i vue-cli -g 创建一个Vue@Cli工程项目： 1vue init webpack vue-name 工程项目创建完成之后会有这些文件： 接下来开始预览： 1npm run dev 浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。 接下来开始打包： 1npm install 但是我这里好像打包失败了，但是不影响 创建软链接[仅root]由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即data&#x2F;data&#x2F;com.termux&#x2F;files目录下。 但是Android提供了软链接。 在Android系统中，用户主文件空间通常位于&#x2F;storage&#x2F;emulated&#x2F;0，但这个名字太长且不易记忆。Android提供了一个软链接路径&#x2F;sdcard，我们可以使用这个路径来简化操作。 1ln -s /data/data/com.termux/files/home/你的项目名称 /sdcard/你的目录","tags":["安卓","vue","Vue@Cli","安卓跑node","Android"],"categories":["技术"]},{"title":"Python编写的一个Feed Rss读取器","path":"/post/2/","content":"123456789101112131415161718192021222324import feedparserdef read_rss_feed(url): feed = feedparser.parse(url) print(&quot;标题:&quot;, feed.feed.title) print(&quot;简介:&quot;, feed.feed.description) print(&quot;链接:&quot;, feed.feed.link) print(&quot; 条目:&quot;) for entry in feed.entries: print(&quot; 标题:&quot;, entry.title) print(&quot;链接:&quot;, entry.link) if &#x27;summary&#x27; in entry: print(&quot;总结:&quot;, entry.summary) elif &#x27;description&#x27; in entry: print(&quot;简介:&quot;, entry.description) print(&quot;=&quot;*50) if __name__ == &quot;__main__&quot;: rss_feed_url = &quot;你的Rss链接&quot; read_rss_feed(rss_feed_url) 先导入了feedparser库。然后定义了一个read_rss_feed的函数。该函数接受一个URL参数，并使用 feedparser.parse(url)来解析该 URL 对应的 RSS 订阅源。接着，打印了整个订阅源的标题、简介和链接，并遍历每个条目并打印其标题、链接以及摘要或描述（如果有的话）。 在程序的主程序入口处，指定了一个 RSS 订阅源的 URL，并调用read_rss_feed函数来解析并打印该订阅源的内容。","tags":["python","feedrss","rss","爬虫","feed"],"categories":["技术"]},{"title":"分享几个自己用PHP写的API代码","path":"/post/9/","content":"每日必应壁纸API这段 PHP 代码的目的是从 Bing 的每日壁纸 API 获取壁纸信息，并根据请求的类型返回壁纸数据或 JSON 格式的壁纸信息。以下是对代码的详细解释和部署后的调用示例。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpfunction getBingWallpaper() &#123; // 构建 Bing 每日壁纸 API 的 URL $url = &#x27;https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&#x27;; // 使用 cURL 发起 HTTP 请求 $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $response = curl_exec($ch); // 检查是否请求成功 if ($response === false) &#123; return false; &#125; // 解析 JSON 响应 $data = json_decode($response, true); // 检查是否解析成功 if (!is_array($data) || empty($data[&#x27;images&#x27;])) &#123; return false; &#125; // 提取壁纸相关信息 $image = $data[&#x27;images&#x27;][0]; $imageUrl = &#x27;https://www.bing.com&#x27; . $image[&#x27;url&#x27;]; $title = $image[&#x27;title&#x27;]; $copyright; // 构建返回数据 $result = [ &#x27;imageUrl&#x27; =&gt; $imageUrl, &#x27;title&#x27; =&gt; $title, ]; return $result;&#125;// 检查传入的参数，确定返回类型$type = isset($_GET[&#x27;type&#x27;]) ? $_GET[&#x27;type&#x27;] : &#x27;json&#x27;;// 调用函数获取壁纸信息$bingWallpaper = getBingWallpaper();// 检查是否成功获取壁纸信息if ($bingWallpaper !== false) &#123; // 根据类型返回数据 if ($type === &#x27;image&#x27;) &#123; // 直接返回图片 header(&#x27;Content-Type: image/jpeg&#x27;); readfile($bingWallpaper[&#x27;imageUrl&#x27;]); &#125; else &#123; // 返回 JSON 格式的壁纸信息 header(&#x27;Content-Type: application/json&#x27;); echo json_encode($bingWallpaper); &#125;&#125; else &#123; // 返回错误信息 header(&#x27;HTTP/1.1 500 Internal Server Error&#x27;); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Failed to fetch Bing wallpaper.&#x27;]);&#125;?&gt; AI生成的代码解析 定义 getBingWallpaper 函数: 123function getBingWallpaper() &#123; // 构建 Bing 每日壁纸 API 的 URL $url = &#x27;https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&#x27;; 该函数通过构建 API 的 URL 来请求 Bing 每日壁纸数据。 idx=0 表示获取今天的壁纸，n=1 表示只获取一张壁纸。 发起 HTTP 请求: 1234$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);$response = curl_exec($ch); 使用 cURL 初始化请求，设置请求的 URL 和返回数据的方式（CURLOPT_RETURNTRANSFER 设置为 true，意味着返回数据会作为字符串输出，而不是直接输出到浏览器）。 执行请求并将响应保存到 $response 变量。 检查请求结果: 123if ($response === false) &#123; return false;&#125; 如果请求失败，函数返回 false。 解析 JSON 响应: 1234$data = json_decode($response, true);if (!is_array($data) || empty($data[&#x27;images&#x27;])) &#123; return false;&#125; 解析 JSON 响应并检查数据格式是否正确。 如果解析失败或响应数据中没有 images 键，则返回 false。 提取壁纸信息: 1234567$image = $data[&#x27;images&#x27;][0];$imageUrl = &#x27;https://www.bing.com&#x27; . $image[&#x27;url&#x27;];$title = $image[&#x27;title&#x27;];$result = [ &#x27;imageUrl&#x27; =&gt; $imageUrl, &#x27;title&#x27; =&gt; $title,]; 提取壁纸的 URL 和标题。 构建包含壁纸信息的数组 $result。 处理请求类型并返回结果: 1234567891011121314$type = isset($_GET[&#x27;type&#x27;]) ? $_GET[&#x27;type&#x27;] : &#x27;json&#x27;;$bingWallpaper = getBingWallpaper();if ($bingWallpaper !== false) &#123; if ($type === &#x27;image&#x27;) &#123; header(&#x27;Content-Type: image/jpeg&#x27;); readfile($bingWallpaper[&#x27;imageUrl&#x27;]); &#125; else &#123; header(&#x27;Content-Type: application/json&#x27;); echo json_encode($bingWallpaper); &#125;&#125; else &#123; header(&#x27;HTTP/1.1 500 Internal Server Error&#x27;); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Failed to fetch Bing wallpaper.&#x27;]);&#125; 根据 type 参数决定返回的内容类型：image 或 json。 如果 type 为 image，设置响应的 Content-Type 为 image/jpeg 并直接读取并输出壁纸图片。 如果 type 为其他值或未设置，返回 JSON 格式的壁纸信息。 如果无法获取壁纸数据，返回 HTTP 500 错误和错误信息。 获取用户IP地址具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpheader(&quot;Content-Type: application/json&quot;);function getRealIpAddr() &#123; $ip = &#x27;&#x27;; // 检查是否存在 HTTP_CLIENT_IP if (!empty($_SERVER[&#x27;HTTP_CLIENT_IP&#x27;])) &#123; $ip = $_SERVER[&#x27;HTTP_CLIENT_IP&#x27;]; &#125; // 检查是否存在 HTTP_X_FORWARDED_FOR，并处理代理 IP 地址列表 elseif (!empty($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $ipList = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $ip = trim(end($ipList)); &#125; // 获取 REMOTE_ADDR 作为备选方案 elseif (!empty($_SERVER[&#x27;REMOTE_ADDR&#x27;])) &#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; &#125; // 对 IP 地址进行验证 if (filter_var($ip, FILTER_VALIDATE_IP)) &#123; return $ip; &#125; else &#123; return &#x27;Unable to determine IP address&#x27;; &#125;&#125;// 获取用户真实 IP 地址$user_ip = getRealIpAddr();// 返回 JSON 格式的 IP 地址$response = array( &#x27;ip&#x27; =&gt; $user_ip);echo json_encode($response);?&gt; AI生成的代码详解 设置响应头: 1header(&quot;Content-Type: application/json&quot;); 设置响应内容的 MIME 类型为 application/json，表明返回的数据格式是 JSON。 定义 getRealIpAddr 函数: 123456789101112131415161718192021222324function getRealIpAddr() &#123; $ip = &#x27;&#x27;; // 检查是否存在 HTTP_CLIENT_IP if (!empty($_SERVER[&#x27;HTTP_CLIENT_IP&#x27;])) &#123; $ip = $_SERVER[&#x27;HTTP_CLIENT_IP&#x27;]; &#125; // 检查是否存在 HTTP_X_FORWARDED_FOR，并处理代理 IP 地址列表 elseif (!empty($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $ipList = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $ip = trim(end($ipList)); &#125; // 获取 REMOTE_ADDR 作为备选方案 elseif (!empty($_SERVER[&#x27;REMOTE_ADDR&#x27;])) &#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; &#125; // 对 IP 地址进行验证 if (filter_var($ip, FILTER_VALIDATE_IP)) &#123; return $ip; &#125; else &#123; return &#x27;Unable to determine IP address&#x27;; &#125;&#125; HTTP_CLIENT_IP: 一般用于检查客户端的真实 IP 地址，如果客户端通过代理服务器访问，可能会存在这个字段。 HTTP_X_FORWARDED_FOR: 这个字段通常会包含代理服务器的 IP 地址链，可能包含多个 IP 地址。这里通过 explode 分割并选择列表中的最后一个 IP 地址作为真实 IP。 REMOTE_ADDR: 如果上述两个字段都没有，则使用 REMOTE_ADDR，这是标准的获取客户端 IP 地址的方式。 使用 filter_var 函数验证 IP 地址的有效性。 获取用户真实 IP 地址: 1$user_ip = getRealIpAddr(); 返回 JSON 格式的 IP 地址: 12345$response = array( &#x27;ip&#x27; =&gt; $user_ip);echo json_encode($response); 将获取的 IP 地址存储在数组 $response 中。 使用 json_encode 函数将数组编码为 JSON 格式并输出。 获取用户UA具体代码如下： 12345678910111213141516171819&lt;?php// 设置响应头，允许跨域访问header(&quot;Access-Control-Allow-Origin: *&quot;);header(&quot;Content-Type: application/json; charset=UTF-8&quot;);// 检查是否有 User Agent 信息if(isset($_SERVER[&#x27;HTTP_USER_AGENT&#x27;])) &#123; // 获取用户的 User Agent 信息 $user_agent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; // 返回 JSON 格式的 User Agent 信息 echo json_encode(array(&quot;user_agent&quot; =&gt; $user_agent));&#125; else &#123; // 如果没有 User Agent 信息，返回错误信息 echo json_encode(array(&quot;error&quot; =&gt; &quot;User Agent not found&quot;));&#125;?&gt; AI生成的代码详解 设置响应头: 12header(&quot;Access-Control-Allow-Origin: *&quot;);header(&quot;Content-Type: application/json; charset=UTF-8&quot;); Access-Control-Allow-Origin: *: 允许所有域名访问此 PHP 脚本。这是为了支持跨域请求，适用于前端应用通过 AJAX 从不同域名访问此脚本。 Content-Type: application/json; charset=UTF-8: 设置响应内容的 MIME 类型为 application/json，并指定字符集为 UTF-8，表明返回的数据格式是 JSON，且使用 UTF-8 编码。 检查 HTTP_USER_AGENT: 1if(isset($_SERVER[&#x27;HTTP_USER_AGENT&#x27;])) &#123; 检查 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 是否被设置，HTTP_USER_AGENT 包含了发起请求的浏览器或客户端的信息。 获取和返回 User Agent 信息: 12$user_agent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];echo json_encode(array(&quot;user_agent&quot; =&gt; $user_agent)); 如果 HTTP_USER_AGENT 存在，获取其值，并将其存储在数组中，然后使用 json_encode 函数将数组编码为 JSON 格式并输出。 处理未找到 User Agent 的情况: 1echo json_encode(array(&quot;error&quot; =&gt; &quot;User Agent not found&quot;)); 如果 HTTP_USER_AGENT 不存在，返回一个包含错误信息的 JSON 对象。 网易热歌榜API具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php// 发送 HTTP 请求获取数据$url = &#x27;http://music.163.com/api/playlist/detail?id=3778678&#x27;; // 热歌榜API接口$response = file_get_contents($url);// 如果使用 curl 库$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);$response = curl_exec($ch);curl_close($ch);if ($response === false) &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;Failed to fetch data from API&#x27;);&#125; else &#123; // 解析 API 响应 $data = json_decode($response, true); if (!$data) &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;Error decoding JSON&#x27;); &#125; elseif (isset($data[&#x27;result&#x27;][&#x27;tracks&#x27;])) &#123; // 处理数据 $tracks = $data[&#x27;result&#x27;][&#x27;tracks&#x27;]; $songList = array(); foreach ($tracks as $track) &#123; $songList[] = array( &#x27;name&#x27; =&gt; $track[&#x27;name&#x27;], &#x27;artist&#x27; =&gt; $track[&#x27;artists&#x27;][0][&#x27;name&#x27;] ); &#125; $result = array(&#x27;songs&#x27; =&gt; $songList); &#125; else &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;未找到歌曲数据&#x27;); &#125;&#125;// 输出 JSON 数据header(&#x27;Content-Type: application/json&#x27;);echo json_encode($result);?&gt; AI生成的代码详解 定义 API URL 并获取数据: 12$url = &#x27;http://music.163.com/api/playlist/detail?id=3778678&#x27;; // 热歌榜API接口$response = file_get_contents($url); $url: 定义了 API 接口的 URL。 file_get_contents($url): 发送 HTTP 请求并获取 API 的响应内容。这是一个简单的方式，但在处理更复杂的请求时可能不够灵活。 使用 cURL 获取数据: 12345$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);$response = curl_exec($ch);curl_close($ch); curl_init(): 初始化 cURL 会话。 curl_setopt(): 设置 cURL 选项： CURLOPT_URL: 设置请求的 URL。 CURLOPT_RETURNTRANSFER: 将 cURL 执行结果作为字符串返回，而不是直接输出。 curl_exec(): 执行 cURL 请求。 curl_close(): 关闭 cURL 会话。 错误处理: 123if ($response === false) &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;Failed to fetch data from API&#x27;);&#125; 如果请求失败，返回一个包含错误信息的 JSON 对象。 解析和处理 API 响应: 1234567891011121314151617$data = json_decode($response, true);if (!$data) &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;Error decoding JSON&#x27;);&#125; elseif (isset($data[&#x27;result&#x27;][&#x27;tracks&#x27;])) &#123; $tracks = $data[&#x27;result&#x27;][&#x27;tracks&#x27;]; $songList = array(); foreach ($tracks as $track) &#123; $songList[] = array( &#x27;name&#x27; =&gt; $track[&#x27;name&#x27;], &#x27;artist&#x27; =&gt; $track[&#x27;artists&#x27;][0][&#x27;name&#x27;] ); &#125; $result = array(&#x27;songs&#x27; =&gt; $songList);&#125; else &#123; $result = array(&#x27;error&#x27; =&gt; &#x27;未找到歌曲数据&#x27;);&#125; json_decode($response, true): 将 JSON 格式的响应解码为 PHP 数组。 错误处理: 如果解码失败，返回包含错误信息的 JSON 对象。 如果响应中包含 result 和 tracks，则提取歌曲信息： 遍历 tracks 数组，将每首歌的名字和第一位艺术家的名字添加到 songList 数组中。 如果没有找到歌曲数据，返回错误信息。 输出 JSON 数据: 12header(&#x27;Content-Type: application/json&#x27;);echo json_encode($result); header(&#39;Content-Type: application/json&#39;): 设置响应的内容类型为 JSON。 json_encode($result): 将结果数组编码为 JSON 格式并输出。","tags":["PHP","PHP开发","API","代码分享","必应壁纸"],"categories":["技术"]},{"title":"文章已加密","path":"/post/8/","content":"仅作者可见","tags":["游戏服务器"],"categories":["其他"]},{"title":"PHP链接数据库的几种方法","path":"/post/7/","content":"前言在PHP中执行SQL查询后，有人就不会读取数据库里面的内容，这里就写上三种读取数据库的方法 fetch_assoc方法使用 fetch_assoc 方法获取关联数组。对于 SELECT 查询，可以使用 fetch_assoc 方法从结果集中获取下一行作为关联数组。每次调用 fetch_assoc 将返回结果集的下一行，直到没有更多行为止。 123456789// fetch_assoc方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_assoc();while ($row !== null) &#123; // ... $row = $result-&gt;fetch_assoc();&#125; fetch_row方法使用 fetch_row 方法获取索引数组。类似地，你也可以使用 fetch_row 方法从结果集中获取下一行作为索引数组。 123456789// fetch_row方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_row();while ($row !== null) &#123; // ... $row = $result-&gt;fetch_row();&#125; fetch_array方法使用 fetch_array 方法获取关联数组或索引数组。fetch_array 方法可以返回关联数组、索引数组或两者兼具的混合数组。你可以传递 MYSQLI_ASSOC、MYSQLI_NUM 或 MYSQLI_BOTH 作为参数来指定返回类型。 12345678910// fetch_array方法$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_array(MYSQLI_ASSOC);while ($row !== null) &#123; // ... $row = $result-&gt;fetch_array(MYSQLI_ASSOC);&#125;","tags":["PHP","MySQL","PHP开发","数据库","MySQLi"],"categories":["技术"]},{"title":"简述pjax及其实现原理","path":"/post/6/","content":"简述pjax及实现方法什么是pjaxpjax是一种无刷新页面加载技术，它利用了浏览器的History API、XMLHttpRequest和HTML5的pushState方法，使得页面无需重新加载就可以实现局部更新。pjax可以让页面的转换更加流畅，并且可以减少服务器负载，提升用户体验。 实现方法1. 引入jquery.pjax.js插件 pjax最初由GitHub团队开发，后来被封装成了jquery.pjax.js插件。在使用pjax之前，需要先引入该插件。 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js&quot;&gt;&lt;/script&gt; 2. 修改a标签在使用pjax的页面中，所有的链接必须添加 data-pjax 属性，以告诉pjax这是一个需要无刷新加载的链接。 1&lt;a href=&quot;/example&quot; data-pjax&gt;Example&lt;/a&gt; 3. 监听pjax事件当用户点击pjax链接时，会触发 pjax:click 事件。我们可以在该事件中执行一些操作，例如显示loading动画等。 123$(document).on(&#x27;pjax:click&#x27;, function() &#123; // 显示loading动画&#125;); 当pjax请求完成并且页面更新成功时，会触发 pjax:success 事件。我们可以在该事件中执行一些操作，例如重置页面状态等。 123$(document).on(&#x27;pjax:success&#x27;, function() &#123; // 重置页面状态&#125;); 4. 配置pjax在使用pjax之前，可以通过 $.pjax.defaults 对象来配置pjax的一些参数，例如容器元素选择器、超时时间等。 12$.pjax.defaults.timeout = 5000;$.pjax.defaults.container = &#x27;#pjax-container&#x27;; pjax技术的实现并不复杂，只需要引入jquery.pjax.js插件，随便改改a标签，监听pjax的事件，配置参数即可。当然，在实际项目中，我们还需要考虑一些安全性、兼容性等问题。pjax可以使页面更加流畅，提升用户体验，但是也需要谨慎使用，避免出现不必要的问题，比如很多JavaScript函数不可用什么的","tags":["Pjax","页面无刷新加载","Pjax原理"],"categories":["技术"]},{"title":"PHP做语法转换工具","path":"/post/5/","content":"最近不是把博客的一些文章从和HTML转到Markdown了吗，因为之前换到了wordpress所以是HTML，但是这些文章再typecho无法被解析，于是就打算开发一个Markdown2HTML工具下面使我的开发笔记，可能比较含糊 项目结构一般情况下，我不会这么干，但是为了文章，还是需要定义的项目结构： 12345678markdown2html/│├── index.php├── convert.php├── styles/│ └── bootstrap.min.css└── js/ └── bootstrap.bundle.min.js index.php: 前端页面，包含输入框和按钮。 convert.php: 后端逻辑处理，将HTML转换为Markdown或将Markdown转换为HTML。 styles/: 存放CSS文件。 js/: 存放JavaScript文件。 准备工作下载Bootstrap从Bootstrap官方网站下载最新版本的Bootstrap，并将bootstrap.min.css放入styles/文件夹，将bootstrap.bundle.min.js放入js/文件夹。也就是所谓的按需导入 编写前端页面 (index.php)编写前端页面，包含一个文本输入框和两个按钮，分别用于将HTML转换为Markdown和将Markdown转换为HTML。这里不要求好看，而且需要快速开发响应式页面，所以选择bootstrap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;转换工具&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container mt-5&quot;&gt; &lt;h1 class=&quot;text-center&quot;&gt;转换工具&lt;/h1&gt; &lt;form id=&quot;convertForm&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;inputText&quot; class=&quot;form-label&quot;&gt;Input Text&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;inputText&quot; name=&quot;inputText&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;d-flex justify-content-between&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; onclick=&quot;convert(&#x27;html2markdown&#x27;)&quot;&gt;HTML转Markdown&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; onclick=&quot;convert(&#x27;markdown2html&#x27;)&quot;&gt;Markdown转HTML&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;label for=&quot;outputText&quot; class=&quot;form-label&quot;&gt;Output Text&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;outputText&quot; name=&quot;outputText&quot; rows=&quot;10&quot; readonly&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=&quot;js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function convert(action) &#123; const form = document.getElementById(&#x27;convertForm&#x27;); const formData = new FormData(form); formData.append(&#x27;action&#x27;, action); fetch(&#x27;convert.php&#x27;, &#123; method: &#x27;POST&#x27;, body: formData &#125;) .then(response =&gt; response.text()) .then(data =&gt; &#123; document.getElementById(&#x27;outputText&#x27;).value = data; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写后端逻辑 (convert.php)接下来，编写后端逻辑，将HTML转换为Markdown或将Markdown转换为HTML。 1234567891011121314151617181920&lt;?phprequire &#x27;vendor/autoload.php&#x27;; // 使用Composer加载依赖use League\\HTMLToMarkdown\\HtmlConverter;use Michelf\\Markdown;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123; $inputText = $_POST[&#x27;inputText&#x27;]; $action = $_POST[&#x27;action&#x27;]; if ($action === &#x27;html2markdown&#x27;) &#123; $converter = new HtmlConverter(); $outputText = $converter-&gt;convert($inputText); &#125; elseif ($action === &#x27;markdown2html&#x27;) &#123; $outputText = Markdown::defaultTransform($inputText); &#125; echo $outputText;&#125;?&gt; 添加依赖需要安装两个PHP库来实现转换功能： Composer是一个包管理器，类似node的npm，和我发现PHP和Vue有异曲同工之妙 league/html-to-markdown: 将HTML转换为Markdown。 michelf/php-markdown: 将Markdown转换为HTML。 在项目根目录下创建一个composer.json文件，内容如下： 123456&#123; &quot;require&quot;: &#123; &quot;league/html-to-markdown&quot;: &quot;^5.0&quot;, &quot;michelf/php-markdown&quot;: &quot;^1.9&quot; &#125;&#125; 然后运行composer install来安装这些依赖。 1composer install 最终效果启动本地服务器（例如使用php -S localhost:8000），访问http://localhost:8000/，就可以看到转换工具的界面了。","tags":["PHP","composer","markdown","语法转换","bootstrap"],"categories":["技术"]},{"title":"万般皆是命，半点不由人","path":"/post/4/","content":"「缘起，是人生的起点；命运，是注定的轨迹。万般皆是命，半点不由人。我们如同棋子，被命运摆弄着在生命的棋局中行走，无法逃离他们所设定的轨迹。然而，就像棋盘上的棋子一样，我们仍然可以选择着自己的落脚点和前进方向。 命运是一幅纷繁复杂的画卷，细细观察，会发现其中蕴含着深刻的道理。曾有一位古代智者说过：“人生自古谁无死，留取丹心照汗青。”这是对人生不可逆转性的深刻揭示。人们常常追求命运的改变，却常常被现实所限制。遗憾的是，我们无法挽回逝去的时光，无法改变已经发生的事实。然而，我们可以从中汲取教训，铭记历史，不要忘记我们曾经的那份初心。 人生的道路充满了艰辛和挫折，就像棋棋高手的棋局一样复杂多变。大师们常说：“棋逢对手，胜负乃前定。”命运的规则在人生的棋盘上显现，我们总是遭遇到强大的对手，面临各种棋局的考验。但我们不应气馁，因为我们始终拥有一个重要的选择权，那就是如何应对困难和挑战。 命运并不全然是一场噩梦，它也为我们埋下了希望的种子。埃莉诺·罗斯福曾经说过：“没有什么可以阻止一个怀揣希望的人。”即使命运摆放了种种难题，我们仍然能够抱着希望勇往直前。正如象棋中兵的进卒，只要它能够坚持到对方阵营，就能够晋升成一位更为强大的棋子。逆境中培养了我们的坚韧和毅力，命运越困难，我们越能够在其中找到希望的曙光。 在人类历史的长河中，智者们留下了许多关于命运的思考。拉伯雷曾说：“人从无法逃离的命运中总是选择假象，真实的命运不是我们创造的，而是被迫接受的。”我们往往倾向于将命运归罪于外界因素，却忽略了内心力量的作用。我们不能将自己束缚在无法逾越的命运轨迹中，而应该在命运的压迫下鼓起勇气，寻找自己的出口。 每个人都是自己命运的雕刻师。命运并不是一成不变的，它可以通过我们的努力而改变。古希腊哲学家伊壁鸠鲁在《幸福的修炼》中说：“命运不好者，很大程度上是因为不懂得在自己能力范围内，尽可能地选择能够给自己更好命运的方式。”我们应该懂得去追求自己内心的渴望，尽可能地创造我们想要的命运。 人生如棋，命运如局。即便被命运束缚，也不要丧失内心的力量和希望。在欢笑与泪水之间，我们渐渐明白，人生的真谛不在于命运的安排，而在于我们对命运的接受和应对。就像棋盘上的棋子，我们可以在有限的空间内创造属于自己的精彩。于须眉之间，凭借着聪明才智，我们与命运对峙，终将收获属于自己的胜利。 命运棋局，我们或落败或成功，但无论如何，我们始终要以从容之心面对命运的安排，在关键时刻做出明智的选择。因为，人生的棋局变幻莫测，命运的走位无常，唯有把握自己的棋局，方能踏上胜利的彼岸。不论人生如何多舛，我们都要坚信：万般皆是命，半点不由人。」","tags":["日常分享"],"categories":["日常"]},{"title":"使用VPS架设Minecraft服务器","path":"/post/1/","content":"前言Minecraft是是一个开放世界沙盒游戏，但是大多数时间都是我们一个人在玩，非常孤独，玩别人的服务器但是限制多多，很多人就想自己当腐竹，但是又不知道怎么开服务器，那么我今天就来说说怎么架设一个基岩版&#x2F;Java版服务器。 准备工具 一台性能足够的Ubuntu系统服务器，2h4g起步 一个SSH连接工具，电脑手机均可 脑子 安装MCSM面板MCSManager 是一款开源，分布式，一键部署，支持 Minecraft 和 Steam 游戏服务器 的控制面板。MCSManager 在 Minecraft 和 其他游戏 社区内中已有一定的流行程度，它可以帮助你集中管理多个物理服务器，动态在任何主机上创建游戏服务端，并且提供安全可靠的多用户权限系统，可以很轻松的帮助你管理多个服务器。 准备环境默认情况下，一键安装脚本应该已经包含一切所需环境。如果是手动安装的情况下，你需满足 Node 16+ 运行时环境。Node 环境下载前往：https://nodejs.org/zh-cn/ 下载一键安装脚本1sudo su -c &quot;wget -qO- https://mcsmanager.com/install-v10.sh | bash&quot; 启动面板1234567891011121314# 先启动面板守护进程。# 这是用于进程控制，终端管理的服务进程。systemctl start mcsm-daemon.service# 再启动面板 Web 服务。# 这是用来实现支持网页访问和用户管理的服务。systemctl start mcsm-web.service# 重启面板命令systemctl restart mcsm-daemon.servicesystemctl restart mcsm-web.service# 停止面板命令systemctl stop mcsm-web.servicesystemctl stop mcsm-daemon.service 架设基岩版服务器前往官网下载服务端： https://www.minecraft.net/zh-hans/download/server/bedrock 下滑，找到Ubuntu版的服务端，点击下载： 下载速度慢可以挂梯子 接下来按照图片一步一步来点击侧边栏 我在这里翻过车，一定要记住，基岩版的启动命令是： 1./bedrock_server Java也大差不差，下载服务端然后启动服务器即可。","tags":["MCSM","游戏服务器","联机","服务器","minecraft"],"categories":["技术"]},{"title":"Hello World","path":"/post/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start文章模板12345678910title: date: tags: - - - - - categories: - 技术 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["1","2","3","4","5"],"categories":["技术"]},{"title":"关于博主","path":"/about/index.html","content":"联系方式 谷歌邮箱：&#77;&#101;&#x6e;&#103;&#x5a;&#x65;&#50;&#77;&#67;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d; QQ邮箱：&#x32;&#x33;&#49;&#55;&#x31;&#x31;&#x33;&#x32;&#x37;&#x38;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109; 企业邮箱：&#x69;&#64;&#109;&#x65;&#110;&#103;&#x7a;&#x65;&#x32;&#x2e;&#99;&#x6e; Outlook邮箱：&#x6c;&#x79;&#108;&#x35;&#49;&#56;&#64;&#111;&#x75;&#x74;&#x6c;&#x6f;&#111;&#x6b;&#46;&#x63;&#x6f;&#109; QQ：2317113278 Xbox：MengZe2 微信：MengZe2_Minecraft Telegram：t.me&#x2F;MengZe_lin Github统计 本站群聊QQ群聊 点击链接加入群聊：https://qm.qq.com/q/SyQggXNisa Telegram频道https://t.me/mengze2cn Telegram群组https://t.me/+\\_hpAIMJKfBJhZDdl"},{"title":"友情链接","path":"/links/index.html","content":"由于一些问题，本站所有友链撤销，需要的评论区重新申请或撤销! 贵站长可在添加小站的友链后在留言板按如下格式留言，我看到留言且确认贵站已添加小站后会第一时间添加并发邮件通知贵站长 友链格式 12345贵站名称：名称贵站简介：简介贵站链接：链接贵站图片：图片站长邮箱：邮箱 ——————————————名称： 梦泽の日记网址： https://mengze2.cn图标： https://mengze2.cn/favicon.ico描述： 我也是普通人，我只不过在追求梦想罢了已添加贵站！—————————————— — 不收录有反动、色情、赌博等不良内容或提供不良内容链接的网站 本页面友链排序没有先后顺序，全都是随机排序 有些删除小站友链的站点小站也会在发现之后删除贵站，这点还望理解 置顶友链https://qq.mbahttps://qq.mba ##普通友链 https://github.com/https://github.com/ https://linexic.tophttps://linexic.top https://blog.awaae001.top/https://blog.awaae001.top/ https://www.iczrx.cn/https://www.iczrx.cn/ https://guardian1l.top/https://guardian1l.top/ https://www.bbixb.top/https://www.bbixb.top/ https://blog.mugzx.top/https://blog.mugzx.top/ https://zhaoq.me/https://zhaoq.me/ https://bbk.endyun.ltd/https://bbk.endyun.ltd/ https://blog.ysbzcn.com/https://blog.ysbzcn.com/ https://www.luochancy.com/https://www.luochancy.com/ https://blog.wuw.moe/https://blog.wuw.moe/ https://www.nekopara.uk:3939/https://www.nekopara.uk:3939/ https://kevinlu98.cn/https://kevinlu98.cn/ https://blog.yaqwq.top/https://blog.yaqwq.top/ https://noobbei.top/https://noobbei.top/ https://yjvc.cn/https://yjvc.cn/ https://dusays.com/https://dusays.com/ https://b.wihi.top/https://b.wihi.top/ https://wuminboke.site/https://wuminboke.site/"},{"path":"/list/index.html","content":"个人业务网址导航 body { margin: 0; font-family: Arial, sans-serif; background: url('background.jpg') no-repeat center center fixed; background-size: cover; color: #fff; } .container { padding: 20px; border-radius: 10px; text-align: center; max-width: 600px; margin: auto; } h1 { font-size: 2.5em; margin-bottom: 20px; } input[type=\"text\"] { padding: 10px; width: 80%; border-radius: 5px; border: none; margin-bottom: 20px; } .url-list { display: flex; flex-direction: column; gap: 10px; backdrop-filter: blur(1px); } 我的网址导航"},{"path":"/list/script.js","content":"document.addEventListener(\"DOMContentLoaded\", function() { const urlList = document.getElementById('urlList'); const searchInput = document.getElementById('searchInput'); let urls = []; fetch('urls.json') .then(response => response.json()) .then(data => { urls = data.urls; displayUrls(urls); console.log(data) }) .catch(error => console.error('Error loading the URL list:', error)); searchInput.addEventListener('input', function() { const searchTerm = searchInput.value.toLowerCase(); const filteredUrls = urls.filter(url => url.name.toLowerCase().includes(searchTerm)); displayUrls(filteredUrls); }); function displayUrls(urls) { urlList.innerHTML = ''; // 清空现有列表 urls.forEach(url => { const a = document.createElement('a'); a.style.backdropFilter = 'blur(1px)'; a.href = url.link; a.className = 'url-item'; a.target = '_blank'; a.textContent = url.name; a.style.background = 'rgba(255, 255, 255, 0.2)'; a.style.padding = '15px'; a.style.borderRadius = '5px'; a.style.textDecoration = 'none'; a.style.color = '#fff'; a.style.transition = 'background 0.3s'; a.onmouseover = () => a.style.background = 'rgba(255, 255, 255, 0.3)'; a.onmouseout = () => a.style.background = 'rgba(255, 255, 255, 0.4)'; urlList.appendChild(a); }); } });"},{"path":"/list/styles.css","content":"body { margin: 0; font-family: Arial, sans-serif; background: url('background.jpg') no-repeat center center fixed; background-size: cover; color: #fff; } .container { padding: 20px; border-radius: 10px; text-align: center; max-width: 600px; margin: auto; } h1 { font-size: 2.5em; margin-bottom: 20px; } input[type=\"text\"] { padding: 10px; width: 80%; border-radius: 5px; border: none; margin-bottom: 20px; } .url-list { display: flex; flex-direction: column; gap: 10px; backdrop-filter: blur(1px); }"},{"path":"/list/urls.json","content":"{\"urls\":[{\"name\":\"技术博客站\",\"link\":\"https://share.mengze2.cn/b3bd3b03\"},{\"name\":\"开源镜像站\",\"link\":\"https://share.mengze2.cn/b31b0\"},{\"name\":\"留言评论站\",\"link\":\"https://share.mengze2.cn/2b329\"},{\"name\":\"免费AI聊天\",\"link\":\"https://share.mengze2.cn/0762a\"},{\"name\":\"谷歌镜像搜索\",\"link\":\"https://share.mengze2.cn/47148\"},{\"name\":\"URL分发系统\",\"link\":\"https://share.mengze2.cn\"},{\"name\":\"Astro原版互通服\",\"link\":\"https://share.mengze2.cn/c2660\"}]}"},{"title":"每日早报","path":"/newspaper/index.html","content":""},{"path":"/links/rss/index.html","content":""},{"title":"免责声明","path":"/privacy-policy/index.html","content":"本博客旨在分享作者的个人技术经验和观点。所有内容仅供参考，不构成任何法律建议或专业意见。作者尽力确保信息准确性和可靠性，但不保证内容的完整性和时效性。 读者在使用本博客提供的信息或建议时，需自行承担风险。对于因使用本博客内容所引发的任何直接或间接损失，作者不承担任何责任。 本博客可能包含第三方链接或推荐的产品或服务，这些链接仅供方便参考，不构成认可或推荐。读者应自行评估并承担使用第三方链接或服务的风险。 作者保留随时更改或修订本免责声明的权利。建议读者定期查阅本页获取最新版本的免责声明。 如有任何疑问或建议，请联系作者。 最后更新日期：[2024-07-03]"}]